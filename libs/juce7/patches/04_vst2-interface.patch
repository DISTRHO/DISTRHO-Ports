diff --git a/extras/AudioPluginHost/CMakeLists.txt b/extras/AudioPluginHost/CMakeLists.txt
index cd7f495e8..091574432 100644
--- a/extras/AudioPluginHost/CMakeLists.txt
+++ b/extras/AudioPluginHost/CMakeLists.txt
@@ -53,7 +53,7 @@ target_compile_definitions(AudioPluginHost PRIVATE
     JUCE_PLUGINHOST_LADSPA=1
     JUCE_PLUGINHOST_LV2=1
     JUCE_PLUGINHOST_VST3=1
-    JUCE_PLUGINHOST_VST=0
+    JUCE_PLUGINHOST_VST=1
     JUCE_PLUGINHOST_ARA=0
     JUCE_USE_CAMERA=0
     JUCE_USE_CDBURNER=0
diff --git a/extras/Build/CMake/JUCEUtils.cmake b/extras/Build/CMake/JUCEUtils.cmake
index 9b2a9cda9..58e65087c 100644
--- a/extras/Build/CMake/JUCEUtils.cmake
+++ b/extras/Build/CMake/JUCEUtils.cmake
@@ -1169,9 +1169,7 @@ function(_juce_configure_plugin_targets target)
         endif()
     endforeach()
 
-    if((VST IN_LIST active_formats) AND (NOT TARGET juce_vst2_sdk))
-        message(FATAL_ERROR "Use juce_set_vst2_sdk_path to set up the VST sdk before adding VST targets")
-    elseif((AAX IN_LIST active_formats) AND (NOT TARGET juce_aax_sdk))
+    if((AAX IN_LIST active_formats) AND (NOT TARGET juce_aax_sdk))
         message(FATAL_ERROR "Use juce_set_aax_sdk_path to set up the AAX sdk before adding AAX targets")
     endif()
 
diff --git a/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp b/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp
index 1127dd252..3fcb6f54a 100644
--- a/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp
+++ b/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp
@@ -78,14 +78,7 @@ JUCE_BEGIN_IGNORE_WARNINGS_MSVC (4458)
 
 namespace Vst2
 {
-// If the following files cannot be found then you are probably trying to build
-// a VST2 plug-in or a VST2-compatible VST3 plug-in. To do this you must have a
-// VST2 SDK in your header search paths or use the "VST (Legacy) SDK Folder"
-// field in the Projucer. The VST2 SDK can be obtained from the
-// vstsdk3610_11_06_2018_build_37 (or older) VST3 SDK or JUCE version 5.3.2. You
-// also need a VST2 license from Steinberg to distribute VST2 plug-ins.
-#include "pluginterfaces/vst2.x/aeffect.h"
-#include "pluginterfaces/vst2.x/aeffectx.h"
+#include "../../juce_audio_processors/format_types/juce_VSTInterface.h"
 }
 
 JUCE_END_IGNORE_WARNINGS_MSVC
@@ -96,7 +89,6 @@ JUCE_END_IGNORE_WARNINGS_GCC_LIKE
  #pragma pack (push, 8)
 #endif
 
-#define JUCE_VSTINTERFACE_H_INCLUDED 1
 #define JUCE_GUI_BASICS_INCLUDE_XHEADERS 1
 
 #include "../utility/juce_IncludeModuleHeaders.h"
@@ -246,7 +238,7 @@ private:
 
 public:
     //==============================================================================
-    JuceVSTWrapper (Vst2::audioMasterCallback cb, std::unique_ptr<AudioProcessor> af)
+    JuceVSTWrapper (Vst2::VstHostCallback cb, std::unique_ptr<AudioProcessor> af)
        : hostCallback (cb),
          processor (std::move (af))
     {
@@ -277,41 +269,41 @@ public:
         juceParameters.update (*processor, false);
 
         memset (&vstEffect, 0, sizeof (vstEffect));
-        vstEffect.magic = 0x56737450 /* 'VstP' */;
-        vstEffect.dispatcher = (Vst2::AEffectDispatcherProc) dispatcherCB;
-        vstEffect.process = nullptr;
-        vstEffect.setParameter = (Vst2::AEffectSetParameterProc) setParameterCB;
-        vstEffect.getParameter = (Vst2::AEffectGetParameterProc) getParameterCB;
+        vstEffect.interfaceIdentifier = Vst2::juceVstInterfaceIdentifier;
+        vstEffect.dispatchFunction = dispatcherCB;
+        vstEffect.processAudioFunction = nullptr;
+        vstEffect.setParameterValueFunction = setParameterCB;
+        vstEffect.getParameterValueFunction = getParameterCB;
         vstEffect.numPrograms = jmax (1, processor->getNumPrograms());
-        vstEffect.numParams = juceParameters.getNumParameters();
-        vstEffect.numInputs = maxNumInChannels;
-        vstEffect.numOutputs = maxNumOutChannels;
-        vstEffect.initialDelay = processor->getLatencySamples();
-        vstEffect.object = this;
-        vstEffect.uniqueID = JucePlugin_VSTUniqueID;
+        vstEffect.numParameters = juceParameters.getNumParameters();
+        vstEffect.numInputChannels = maxNumInChannels;
+        vstEffect.numOutputChannels = maxNumOutChannels;
+        vstEffect.latency = processor->getLatencySamples();
+        vstEffect.effectPointer = this;
+        vstEffect.plugInIdentifier = JucePlugin_VSTUniqueID;
 
        #ifdef JucePlugin_VSTChunkStructureVersion
-        vstEffect.version = JucePlugin_VSTChunkStructureVersion;
+        vstEffect.plugInVersion = JucePlugin_VSTChunkStructureVersion;
        #else
-        vstEffect.version = JucePlugin_VersionCode;
+        vstEffect.plugInVersion = JucePlugin_VersionCode;
        #endif
 
-        vstEffect.processReplacing = (Vst2::AEffectProcessProc) processReplacingCB;
-        vstEffect.processDoubleReplacing = (Vst2::AEffectProcessDoubleProc) processDoubleReplacingCB;
+        vstEffect.processAudioInplaceFunction = processReplacingCB;
+        vstEffect.processDoubleAudioInplaceFunction = processDoubleReplacingCB;
 
-        vstEffect.flags |= Vst2::effFlagsHasEditor;
+        vstEffect.flags |= Vst2::vstEffectFlagHasEditor;
 
-        vstEffect.flags |= Vst2::effFlagsCanReplacing;
+        vstEffect.flags |= Vst2::vstEffectFlagInplaceAudio;
         if (processor->supportsDoublePrecisionProcessing())
-            vstEffect.flags |= Vst2::effFlagsCanDoubleReplacing;
+            vstEffect.flags |= Vst2::vstEffectFlagInplaceDoubleAudio;
 
-        vstEffect.flags |= Vst2::effFlagsProgramChunks;
+        vstEffect.flags |= Vst2::vstEffectFlagDataInChunks;
 
        #if JucePlugin_IsSynth
-        vstEffect.flags |= Vst2::effFlagsIsSynth;
+        vstEffect.flags |= Vst2::vstEffectFlagIsSynth;
        #else
         if (processor->getTailLengthSeconds() == 0.0)
-            vstEffect.flags |= Vst2::effFlagsNoSoundInStop;
+            vstEffect.flags |= 512;
        #endif
 
        #if JUCE_WINDOWS
@@ -345,7 +337,7 @@ public:
         }
     }
 
-    Vst2::AEffect* getAEffect() noexcept    { return &vstEffect; }
+    Vst2::VstEffectInterface* getAEffect() noexcept    { return &vstEffect; }
 
     template <typename FloatType>
     void internalProcessReplacing (FloatType** inputs, FloatType** outputs,
@@ -480,7 +472,7 @@ public:
 
             // Send VST events to the host.
             if (hostCallback != nullptr)
-                hostCallback (&vstEffect, Vst2::audioMasterProcessEvents, 0, 0, outgoingEvents.events, 0);
+                hostCallback (&vstEffect, Vst2::hostOpcodePreAudioProcessingEvents, 0, 0, outgoingEvents.events, 0);
            #elif JUCE_DEBUG
             /*  This assertion is caused when you've added some events to the
                 midiMessages array in your processBlock() method, which usually means
@@ -509,7 +501,7 @@ public:
         internalProcessReplacing (inputs, outputs, sampleFrames, floatTempBuffers);
     }
 
-    static void processReplacingCB (Vst2::AEffect* vstInterface, float** inputs, float** outputs, int32 sampleFrames)
+    static void processReplacingCB (Vst2::VstEffectInterface* vstInterface, float** inputs, float** outputs, int32 sampleFrames)
     {
         getWrapper (vstInterface)->processReplacing (inputs, outputs, sampleFrames);
     }
@@ -520,7 +512,7 @@ public:
         internalProcessReplacing (inputs, outputs, sampleFrames, doubleTempBuffers);
     }
 
-    static void processDoubleReplacingCB (Vst2::AEffect* vstInterface, double** inputs, double** outputs, int32 sampleFrames)
+    static void processDoubleReplacingCB (Vst2::VstEffectInterface* vstInterface, double** inputs, double** outputs, int32 sampleFrames)
     {
         getWrapper (vstInterface)->processDoubleReplacing (inputs, outputs, sampleFrames);
     }
@@ -532,7 +524,7 @@ public:
         {
             isProcessing = true;
 
-            auto numInAndOutChannels = static_cast<size_t> (vstEffect.numInputs + vstEffect.numOutputs);
+            auto numInAndOutChannels = static_cast<size_t> (vstEffect.numInputChannels + vstEffect.numOutputChannels);
             floatTempBuffers .channels.calloc (numInAndOutChannels);
             doubleTempBuffers.channels.calloc (numInAndOutChannels);
 
@@ -551,16 +543,16 @@ public:
             midiEvents.ensureSize (2048);
             midiEvents.clear();
 
-            vstEffect.initialDelay = processor->getLatencySamples();
+            vstEffect.latency = processor->getLatencySamples();
 
             /** If this plug-in is a synth or it can receive midi events we need to tell the
                 host that we want midi. In the SDK this method is marked as deprecated, but
                 some hosts rely on this behaviour.
             */
-            if (vstEffect.flags & Vst2::effFlagsIsSynth || JucePlugin_WantsMidiInput || JucePlugin_IsMidiEffect)
+            if (vstEffect.flags & Vst2::vstEffectFlagIsSynth || JucePlugin_WantsMidiInput || JucePlugin_IsMidiEffect)
             {
                 if (hostCallback != nullptr)
-                    hostCallback (&vstEffect, Vst2::audioMasterWantMidi, 0, 1, nullptr, 0);
+                    hostCallback (&vstEffect, Vst2::hostOpcodePlugInWantsMidi, 0, 1, nullptr, 0);
             }
 
             if (getHostType().isAbletonLive()
@@ -574,7 +566,7 @@ public:
                 hostCmd.commandSize = sizeof (int);
                 hostCmd.flags = AbletonLiveHostSpecific::KCantBeSuspended;
 
-                hostCallback (&vstEffect, Vst2::audioMasterVendorSpecific, 0, 0, &hostCmd, 0.0f);
+                hostCallback (&vstEffect, Vst2::hostOpcodeManufacturerSpecific, 0, 0, &hostCmd, 0.0f);
             }
 
            #if JucePlugin_ProducesMidiOutput || JucePlugin_IsMidiEffect
@@ -600,17 +592,17 @@ public:
 
     void updateCallbackContextInfo()
     {
-        const Vst2::VstTimeInfo* ti = nullptr;
+        const Vst2::VstTimingInformation* ti = nullptr;
 
         if (hostCallback != nullptr)
         {
-            int32 flags = Vst2::kVstPpqPosValid  | Vst2::kVstTempoValid
-                          | Vst2::kVstBarsValid    | Vst2::kVstCyclePosValid
-                          | Vst2::kVstTimeSigValid | Vst2::kVstSmpteValid
-                          | Vst2::kVstClockValid   | Vst2::kVstNanosValid;
+            int32 flags = Vst2::vstTimingInfoFlagMusicalPositionValid    | Vst2::vstTimingInfoFlagTempoValid
+                          | Vst2::vstTimingInfoFlagLastBarPositionValid  | Vst2::vstTimingInfoFlagLoopPositionValid
+                          | Vst2::vstTimingInfoFlagTimeSignatureValid    | Vst2::vstTimingInfoFlagSmpteValid
+                          | Vst2::vstTimingInfoFlagNearestClockValid     | Vst2::vstTimingInfoFlagNanosecondsValid;
 
-            auto result = hostCallback (&vstEffect, Vst2::audioMasterGetTime, 0, flags, nullptr, 0);
-            ti = reinterpret_cast<Vst2::VstTimeInfo*> (result);
+            auto result = hostCallback (&vstEffect, Vst2::hostOpcodeGetTimingInfo, 0, flags, nullptr, 0);
+            ti = reinterpret_cast<Vst2::VstTimingInformation*> (result);
         }
 
         if (ti == nullptr || ti->sampleRate <= 0)
@@ -620,38 +612,38 @@ public:
         }
 
         auto& info = currentPosition.emplace();
-        info.setBpm ((ti->flags & Vst2::kVstTempoValid) != 0 ? makeOptional (ti->tempo) : nullopt);
+        info.setBpm ((ti->flags & Vst2::vstTimingInfoFlagTempoValid) != 0 ? makeOptional (ti->tempoBPM) : nullopt);
 
-        info.setTimeSignature ((ti->flags & Vst2::kVstTimeSigValid) != 0 ? makeOptional (TimeSignature { ti->timeSigNumerator, ti->timeSigDenominator })
-                                                                         : nullopt);
+        info.setTimeSignature ((ti->flags & Vst2::vstTimingInfoFlagTimeSignatureValid) != 0 ? makeOptional (TimeSignature { ti->timeSignatureNumerator, ti->timeSignatureDenominator })
+                                                                                       : nullopt);
 
-        info.setTimeInSamples ((int64) (ti->samplePos + 0.5));
-        info.setTimeInSeconds (ti->samplePos / ti->sampleRate);
-        info.setPpqPosition ((ti->flags & Vst2::kVstPpqPosValid) != 0 ? makeOptional (ti->ppqPos) : nullopt);
-        info.setPpqPositionOfLastBarStart ((ti->flags & Vst2::kVstBarsValid) != 0 ? makeOptional (ti->barStartPos) : nullopt);
+        info.setTimeInSamples ((int64) (ti->samplePosition + 0.5));
+        info.setTimeInSeconds (ti->samplePosition / ti->sampleRate);
+        info.setPpqPosition ((ti->flags & Vst2::vstTimingInfoFlagMusicalPositionValid) != 0 ? makeOptional (ti->musicalPosition) : nullopt);
+        info.setPpqPositionOfLastBarStart ((ti->flags & Vst2::vstTimingInfoFlagLastBarPositionValid) != 0 ? makeOptional (ti->lastBarPosition) : nullopt);
 
-        if ((ti->flags & Vst2::kVstSmpteValid) != 0)
+        if ((ti->flags & Vst2::vstTimingInfoFlagSmpteValid) != 0)
         {
             info.setFrameRate ([&]() -> Optional<FrameRate>
             {
-                switch (ti->smpteFrameRate)
+                switch (ti->smpteRate)
                 {
-                    case Vst2::kVstSmpte24fps:          return FrameRate().withBaseRate (24);
-                    case Vst2::kVstSmpte239fps:         return FrameRate().withBaseRate (24).withPullDown();
+                    case Vst2::vstSmpteRateFps24:          return FrameRate().withBaseRate (24);
+                    case Vst2::vstSmpteRateFps239:         return FrameRate().withBaseRate (24).withPullDown();
 
-                    case Vst2::kVstSmpte25fps:          return FrameRate().withBaseRate (25);
-                    case Vst2::kVstSmpte249fps:         return FrameRate().withBaseRate (25).withPullDown();
+                    case Vst2::vstSmpteRateFps25:          return FrameRate().withBaseRate (25);
+                    case Vst2::vstSmpteRateFps249:         return FrameRate().withBaseRate (25).withPullDown();
 
-                    case Vst2::kVstSmpte30fps:          return FrameRate().withBaseRate (30);
-                    case Vst2::kVstSmpte30dfps:         return FrameRate().withBaseRate (30).withDrop();
-                    case Vst2::kVstSmpte2997fps:        return FrameRate().withBaseRate (30).withPullDown();
-                    case Vst2::kVstSmpte2997dfps:       return FrameRate().withBaseRate (30).withPullDown().withDrop();
+                    case Vst2::vstSmpteRateFps30:          return FrameRate().withBaseRate (30);
+                    case Vst2::vstSmpteRateFps30drop:      return FrameRate().withBaseRate (30).withDrop();
+                    case Vst2::vstSmpteRateFps2997:        return FrameRate().withBaseRate (30).withPullDown();
+                    case Vst2::vstSmpteRateFps2997drop:    return FrameRate().withBaseRate (30).withPullDown().withDrop();
 
-                    case Vst2::kVstSmpte60fps:          return FrameRate().withBaseRate (60);
-                    case Vst2::kVstSmpte599fps:         return FrameRate().withBaseRate (60).withPullDown();
+                    case Vst2::vstSmpteRateFps60:          return FrameRate().withBaseRate (60);
+                    case Vst2::vstSmpteRateFps599:         return FrameRate().withBaseRate (60).withPullDown();
 
-                    case Vst2::kVstSmpteFilm16mm:
-                    case Vst2::kVstSmpteFilm35mm:       return FrameRate().withBaseRate (24);
+                    case Vst2::vstSmpteRate16mmFilm:
+                    case Vst2::vstSmpteRate35mmFilm:       return FrameRate().withBaseRate (24);
                 }
 
                 return nullopt;
@@ -661,14 +653,14 @@ public:
             info.setEditOriginTime (effectiveRate != 0.0 ? makeOptional (ti->smpteOffset / (80.0 * effectiveRate)) : nullopt);
         }
 
-        info.setIsRecording ((ti->flags & Vst2::kVstTransportRecording) != 0);
-        info.setIsPlaying   ((ti->flags & (Vst2::kVstTransportRecording | Vst2::kVstTransportPlaying)) != 0);
-        info.setIsLooping   ((ti->flags & Vst2::kVstTransportCycleActive) != 0);
+        info.setIsRecording ((ti->flags & Vst2::vstTimingInfoFlagCurrentlyRecording) != 0);
+        info.setIsPlaying   ((ti->flags & (Vst2::vstTimingInfoFlagCurrentlyRecording | Vst2::vstTimingInfoFlagCurrentlyPlaying)) != 0);
+        info.setIsLooping   ((ti->flags & Vst2::vstTimingInfoFlagLoopActive) != 0);
 
-        info.setLoopPoints ((ti->flags & Vst2::kVstCyclePosValid) != 0 ? makeOptional (LoopPoints { ti->cycleStartPos, ti->cycleEndPos })
-                                                                       : nullopt);
+        info.setLoopPoints ((ti->flags & Vst2::vstTimingInfoFlagLoopPositionValid) != 0 ? makeOptional (LoopPoints { ti->loopStartPosition, ti->loopEndPosition })
+                                                                                        : nullopt);
 
-        info.setHostTimeNs ((ti->flags & Vst2::kVstNanosValid) != 0 ? makeOptional ((uint64_t) ti->nanoSeconds) : nullopt);
+        info.setHostTimeNs ((ti->flags & Vst2::vstTimingInfoFlagNanosecondsValid) != 0 ? makeOptional ((uint64_t) ti->systemTimeNanoseconds) : nullopt);
     }
 
     //==============================================================================
@@ -686,7 +678,7 @@ public:
         return 0.0f;
     }
 
-    static float getParameterCB (Vst2::AEffect* vstInterface, int32 index)
+    static float getParameterCB (Vst2::VstEffectInterface* vstInterface, int32 index)
     {
         return getWrapper (vstInterface)->getParameter (index);
     }
@@ -697,7 +689,7 @@ public:
             setValueAndNotifyIfChanged (*param, value);
     }
 
-    static void setParameterCB (Vst2::AEffect* vstInterface, int32 index, float value)
+    static void setParameterCB (Vst2::VstEffectInterface* vstInterface, int32 index, float value)
     {
         getWrapper (vstInterface)->setParameter (index, value);
     }
@@ -711,19 +703,19 @@ public:
         }
 
         if (hostCallback != nullptr)
-            hostCallback (&vstEffect, Vst2::audioMasterAutomate, index, 0, nullptr, newValue);
+            hostCallback (&vstEffect, Vst2::hostOpcodeParameterChanged, index, 0, nullptr, newValue);
     }
 
     void audioProcessorParameterChangeGestureBegin (AudioProcessor*, int index) override
     {
         if (hostCallback != nullptr)
-            hostCallback (&vstEffect, Vst2::audioMasterBeginEdit, index, 0, nullptr, 0);
+            hostCallback (&vstEffect, Vst2::hostOpcodeParameterChangeGestureBegin, index, 0, nullptr, 0);
     }
 
     void audioProcessorParameterChangeGestureEnd (AudioProcessor*, int index) override
     {
         if (hostCallback != nullptr)
-            hostCallback (&vstEffect, Vst2::audioMasterEndEdit, index, 0, nullptr, 0);
+            hostCallback (&vstEffect, Vst2::hostOpcodeParameterChangeGestureEnd, index, 0, nullptr, 0);
     }
 
     void parameterValueChanged (int, float newValue) override
@@ -739,7 +731,7 @@ public:
         hostChangeUpdater.update (details);
     }
 
-    bool getPinProperties (Vst2::VstPinProperties& properties, bool direction, int index) const
+    bool getPinProperties (Vst2::VstPinInfo& properties, bool direction, int index) const
     {
         if (processor->isMidiEffect())
             return false;
@@ -748,9 +740,9 @@ public:
 
         // fill with default
         properties.flags = 0;
-        properties.label[0] = 0;
-        properties.shortLabel[0] = 0;
-        properties.arrangementType = Vst2::kSpeakerArrEmpty;
+        properties.text[0] = 0;
+        properties.shortText[0] = 0;
+        properties.configurationType = Vst2::vstSpeakerConfigTypeEmpty;
 
         if ((channelIdx = processor->getOffsetInBusBufferForAbsoluteChannelIndex (direction, index, busIdx)) >= 0)
         {
@@ -758,8 +750,8 @@ public:
             auto& channelSet = bus.getCurrentLayout();
             auto channelType = channelSet.getTypeOfChannel (channelIdx);
 
-            properties.flags = Vst2::kVstPinIsActive | Vst2::kVstPinUseSpeaker;
-            properties.arrangementType = SpeakerMappings::channelSetToVstArrangementType (channelSet);
+            properties.flags = Vst2::vstPinInfoFlagIsActive | Vst2::vstPinInfoFlagValid;
+            properties.configurationType = SpeakerMappings::channelSetToVstArrangementType (channelSet);
             String label = bus.getName();
 
            #ifdef JucePlugin_PreferredChannelConfigurations
@@ -769,8 +761,8 @@ public:
                 label += " " + AudioChannelSet::getAbbreviatedChannelTypeName (channelType);
            #endif
 
-            label.copyToUTF8 (properties.label, (size_t) (Vst2::kVstMaxLabelLen + 1));
-            label.copyToUTF8 (properties.shortLabel, (size_t) (Vst2::kVstMaxShortLabelLen + 1));
+            label.copyToUTF8 (properties.text, (size_t) (Vst2::vstMaxParameterOrPinLabelLength + 1));
+            label.copyToUTF8 (properties.shortText, (size_t) (Vst2::vstMaxParameterOrPinShortLabelLength + 1));
 
             if (channelType == AudioChannelSet::left
                 || channelType == AudioChannelSet::leftSurround
@@ -780,7 +772,7 @@ public:
                 || channelType == AudioChannelSet::topRearLeft
                 || channelType == AudioChannelSet::leftSurroundRear
                 || channelType == AudioChannelSet::wideLeft)
-                properties.flags |= Vst2::kVstPinIsStereo;
+                properties.flags |= Vst2::vstPinInfoFlagIsStereo;
 
             return true;
         }
@@ -815,15 +807,15 @@ public:
 
     void setHasEditorFlag (bool shouldSetHasEditor)
     {
-        auto hasEditor = (vstEffect.flags & Vst2::effFlagsHasEditor) != 0;
+        auto hasEditor = (vstEffect.flags & Vst2::vstEffectFlagHasEditor) != 0;
 
         if (shouldSetHasEditor == hasEditor)
             return;
 
         if (shouldSetHasEditor)
-            vstEffect.flags |= Vst2::effFlagsHasEditor;
+            vstEffect.flags |= Vst2::vstEffectFlagHasEditor;
         else
-            vstEffect.flags &= ~Vst2::effFlagsHasEditor;
+            vstEffect.flags &= ~Vst2::vstEffectFlagHasEditor;
     }
 
     void createEditorComp()
@@ -890,60 +882,60 @@ public:
 
         switch (opCode)
         {
-            case Vst2::effOpen:                     return handleOpen (args);
-            case Vst2::effClose:                    return handleClose (args);
-            case Vst2::effSetProgram:               return handleSetCurrentProgram (args);
-            case Vst2::effGetProgram:               return handleGetCurrentProgram (args);
-            case Vst2::effSetProgramName:           return handleSetCurrentProgramName (args);
-            case Vst2::effGetProgramName:           return handleGetCurrentProgramName (args);
-            case Vst2::effGetParamLabel:            return handleGetParameterLabel (args);
-            case Vst2::effGetParamDisplay:          return handleGetParameterText (args);
-            case Vst2::effGetParamName:             return handleGetParameterName (args);
-            case Vst2::effSetSampleRate:            return handleSetSampleRate (args);
-            case Vst2::effSetBlockSize:             return handleSetBlockSize (args);
-            case Vst2::effMainsChanged:             return handleResumeSuspend (args);
-            case Vst2::effEditGetRect:              return handleGetEditorBounds (args);
-            case Vst2::effEditOpen:                 return handleOpenEditor (args);
-            case Vst2::effEditClose:                return handleCloseEditor (args);
-            case Vst2::effIdentify:                 return (pointer_sized_int) ByteOrder::bigEndianInt ("NvEf");
-            case Vst2::effGetChunk:                 return handleGetData (args);
-            case Vst2::effSetChunk:                 return handleSetData (args);
-            case Vst2::effProcessEvents:            return handlePreAudioProcessingEvents (args);
-            case Vst2::effCanBeAutomated:           return handleIsParameterAutomatable (args);
-            case Vst2::effString2Parameter:         return handleParameterValueForText (args);
-            case Vst2::effGetProgramNameIndexed:    return handleGetProgramName (args);
-            case Vst2::effGetInputProperties:       return handleGetInputPinProperties (args);
-            case Vst2::effGetOutputProperties:      return handleGetOutputPinProperties (args);
-            case Vst2::effGetPlugCategory:          return handleGetPlugInCategory (args);
-            case Vst2::effSetSpeakerArrangement:    return handleSetSpeakerConfiguration (args);
-            case Vst2::effSetBypass:                return handleSetBypass (args);
-            case Vst2::effGetEffectName:            return handleGetPlugInName (args);
-            case Vst2::effGetProductString:         return handleGetPlugInName (args);
-            case Vst2::effGetVendorString:          return handleGetManufacturerName (args);
-            case Vst2::effGetVendorVersion:         return handleGetManufacturerVersion (args);
-            case Vst2::effVendorSpecific:           return handleManufacturerSpecific (args);
-            case Vst2::effCanDo:                    return handleCanPlugInDo (args);
-            case Vst2::effGetTailSize:              return handleGetTailSize (args);
-            case Vst2::effKeysRequired:             return handleKeyboardFocusRequired (args);
-            case Vst2::effGetVstVersion:            return handleGetVstInterfaceVersion (args);
-            case Vst2::effGetCurrentMidiProgram:    return handleGetCurrentMidiProgram (args);
-            case Vst2::effGetSpeakerArrangement:    return handleGetSpeakerConfiguration (args);
-            case Vst2::effSetTotalSampleToProcess:  return handleSetNumberOfSamplesToProcess (args);
-            case Vst2::effSetProcessPrecision:      return handleSetSampleFloatType (args);
-            case Vst2::effGetNumMidiInputChannels:  return handleGetNumMidiInputChannels();
-            case Vst2::effGetNumMidiOutputChannels: return handleGetNumMidiOutputChannels();
-            case Vst2::effEditIdle:                 return handleEditIdle();
-            default:                                return 0;
-        }
-    }
-
-    static pointer_sized_int dispatcherCB (Vst2::AEffect* vstInterface, int32 opCode, int32 index,
+            case Vst2::plugInOpcodeOpen:                        return handleOpen (args);
+            case Vst2::plugInOpcodeClose:                       return handleClose (args);
+            case Vst2::plugInOpcodeSetCurrentProgram:           return handleSetCurrentProgram (args);
+            case Vst2::plugInOpcodeGetCurrentProgram:           return handleGetCurrentProgram (args);
+            case Vst2::plugInOpcodeSetCurrentProgramName:       return handleSetCurrentProgramName (args);
+            case Vst2::plugInOpcodeGetCurrentProgramName:       return handleGetCurrentProgramName (args);
+            case Vst2::plugInOpcodeGetParameterLabel:           return handleGetParameterLabel (args);
+            case Vst2::plugInOpcodeGetParameterText:            return handleGetParameterText (args);
+            case Vst2::plugInOpcodeGetParameterName:            return handleGetParameterName (args);
+            case Vst2::plugInOpcodeSetSampleRate:               return handleSetSampleRate (args);
+            case Vst2::plugInOpcodeSetBlockSize:                return handleSetBlockSize (args);
+            case Vst2::plugInOpcodeResumeSuspend:               return handleResumeSuspend (args);
+            case Vst2::plugInOpcodeGetEditorBounds:             return handleGetEditorBounds (args);
+            case Vst2::plugInOpcodeOpenEditor:                  return handleOpenEditor (args);
+            case Vst2::plugInOpcodeCloseEditor:                 return handleCloseEditor (args);
+            case Vst2::plugInOpcodeIdentify:                    return (pointer_sized_int) ByteOrder::bigEndianInt ("NvEf");
+            case Vst2::plugInOpcodeGetData:                     return handleGetData (args);
+            case Vst2::plugInOpcodeSetData:                     return handleSetData (args);
+            case Vst2::plugInOpcodePreAudioProcessingEvents:    return handlePreAudioProcessingEvents (args);
+            case Vst2::plugInOpcodeIsParameterAutomatable:      return handleIsParameterAutomatable (args);
+            case Vst2::plugInOpcodeParameterValueForText:       return handleParameterValueForText (args);
+            case Vst2::plugInOpcodeGetProgramName:              return handleGetProgramName (args);
+            case Vst2::plugInOpcodeGetInputPinProperties:       return handleGetInputPinProperties (args);
+            case Vst2::plugInOpcodeGetOutputPinProperties:      return handleGetOutputPinProperties (args);
+            case Vst2::plugInOpcodeGetPlugInCategory:           return handleGetPlugInCategory (args);
+            case Vst2::plugInOpcodeSetSpeakerConfiguration:     return handleSetSpeakerConfiguration (args);
+            case Vst2::plugInOpcodeSetBypass:                   return handleSetBypass (args);
+            case Vst2::plugInOpcodeGetPlugInName:               return handleGetPlugInName (args);
+            case Vst2::plugInOpcodeGetManufacturerProductName:  return handleGetPlugInName (args);
+            case Vst2::plugInOpcodeGetManufacturerName:         return handleGetManufacturerName (args);
+            case Vst2::plugInOpcodeGetManufacturerVersion:      return handleGetManufacturerVersion (args);
+            case Vst2::plugInOpcodeManufacturerSpecific:        return handleManufacturerSpecific (args);
+            case Vst2::plugInOpcodeCanPlugInDo:                 return handleCanPlugInDo (args);
+            case Vst2::plugInOpcodeGetTailSize:                 return handleGetTailSize (args);
+            case Vst2::plugInOpcodeKeyboardFocusRequired:       return handleKeyboardFocusRequired (args);
+            case Vst2::plugInOpcodeGetVstInterfaceVersion:      return handleGetVstInterfaceVersion (args);
+            case Vst2::plugInOpcodeGetCurrentMidiProgram:       return handleGetCurrentMidiProgram (args);
+            case Vst2::plugInOpcodeGetSpeakerArrangement:       return handleGetSpeakerConfiguration (args);
+            case Vst2::plugInOpcodeSetNumberOfSamplesToProcess: return handleSetNumberOfSamplesToProcess (args);
+            case Vst2::plugInOpcodeSetSampleFloatType:          return handleSetSampleFloatType (args);
+            case Vst2::pluginOpcodeGetNumMidiInputChannels:     return handleGetNumMidiInputChannels();
+            case Vst2::pluginOpcodeGetNumMidiOutputChannels:    return handleGetNumMidiOutputChannels();
+            case Vst2::plugInOpcodeEditorIdle:                  return handleEditIdle();
+            default:                                            return 0;
+        }
+    }
+
+    static pointer_sized_int dispatcherCB (Vst2::VstEffectInterface* vstInterface, int32 opCode, int32 index,
                                            pointer_sized_int value, void* ptr, float opt)
     {
         auto* wrapper = getWrapper (vstInterface);
         VstOpCodeArguments args = { index, value, ptr, opt };
 
-        if (opCode == Vst2::effClose)
+        if (opCode == Vst2::plugInOpcodeClose)
         {
             wrapper->dispatcher (opCode, args);
             delete wrapper;
@@ -994,7 +986,7 @@ public:
             g.fillAll (Colours::black);
         }
 
-        void getEditorBounds (Vst2::ERect& bounds)
+        void getEditorBounds (Vst2::VstEditorBounds& bounds)
         {
             auto editorBounds = getSizeToContainChild();
             bounds = convertToHostBounds ({ 0, 0, (int16) editorBounds.getHeight(), (int16) editorBounds.getWidth() });
@@ -1107,20 +1099,20 @@ public:
         void resizeHostWindow (juce::Rectangle<int> bounds)
         {
             auto rect = convertToHostBounds ({ 0, 0, (int16) bounds.getHeight(), (int16) bounds.getWidth() });
-            const auto newWidth = rect.right - rect.left;
-            const auto newHeight = rect.bottom - rect.top;
+            const auto newWidth = rect.rightmost - rect.leftmost;
+            const auto newHeight = rect.lower - rect.upper;
 
             bool sizeWasSuccessful = false;
 
             if (auto host = wrapper.hostCallback)
             {
-                auto status = host (wrapper.getAEffect(), Vst2::audioMasterCanDo, 0, 0, const_cast<char*> ("sizeWindow"), 0);
+                auto status = host (wrapper.getAEffect(), Vst2::hostOpcodeCanHostDo, 0, 0, const_cast<char*> ("sizeWindow"), 0);
 
                 if (status == (pointer_sized_int) 1 || getHostType().isAbletonLive())
                 {
                     const ScopedValueSetter<bool> resizingParentSetter (resizingParent, true);
 
-                    sizeWasSuccessful = (host (wrapper.getAEffect(), Vst2::audioMasterSizeWindow,
+                    sizeWasSuccessful = (host (wrapper.getAEffect(), Vst2::hostOpcodeWindowSize,
                                                newWidth, newHeight, nullptr, 0) != 0);
                 }
             }
@@ -1183,8 +1175,8 @@ public:
 
            #if JUCE_LINUX || JUCE_BSD
             X11Symbols::getInstance()->xResizeWindow (display, (Window) getWindowHandle(),
-                                                      static_cast<unsigned int> (rect.right - rect.left),
-                                                      static_cast<unsigned int> (rect.bottom - rect.top));
+                                                      static_cast<unsigned int> (rect.rightmost - rect.leftmost),
+                                                      static_cast<unsigned int> (rect.lower - rect.upper));
            #endif
         }
 
@@ -1276,17 +1268,17 @@ public:
         }
 
         //==============================================================================
-        static Vst2::ERect convertToHostBounds (const Vst2::ERect& rect)
+        static Vst2::VstEditorBounds convertToHostBounds (const Vst2::VstEditorBounds& rect)
         {
             auto desktopScale = Desktop::getInstance().getGlobalScaleFactor();
 
             if (approximatelyEqual (desktopScale, 1.0f))
                 return rect;
 
-            return { (int16) roundToInt (rect.top    * desktopScale),
-                     (int16) roundToInt (rect.left   * desktopScale),
-                     (int16) roundToInt (rect.bottom * desktopScale),
-                     (int16) roundToInt (rect.right  * desktopScale) };
+            return { (int16) roundToInt (rect.upper      * desktopScale),
+                     (int16) roundToInt (rect.leftmost   * desktopScale),
+                     (int16) roundToInt (rect.lower      * desktopScale),
+                     (int16) roundToInt (rect.rightmost  * desktopScale)};
         }
 
         //==============================================================================
@@ -1326,7 +1318,7 @@ private:
         {
             if (details.latencyChanged)
             {
-                owner.vstEffect.initialDelay = owner.processor->getLatencySamples();
+                owner.vstEffect.latency = owner.processor->getLatencySamples();
                 callbackBits |= audioMasterIOChangedBit;
             }
 
@@ -1345,12 +1337,12 @@ private:
             {
                 struct FlagPair
                 {
-                    Vst2::AudioMasterOpcodesX opcode;
+                    int32 opcode;
                     int bit;
                 };
 
-                constexpr FlagPair pairs[] { { Vst2::audioMasterUpdateDisplay, audioMasterUpdateDisplayBit },
-                                             { Vst2::audioMasterIOChanged,     audioMasterIOChangedBit } };
+                constexpr FlagPair pairs[] { { Vst2::hostOpcodeUpdateView, audioMasterUpdateDisplayBit },
+                                             { Vst2::hostOpcodeIOModified, audioMasterIOChangedBit } };
 
                 for (const auto& pair : pairs)
                     if ((callbacksToFire & pair.bit) != 0)
@@ -1365,12 +1357,12 @@ private:
         std::atomic<int> callbackBits { 0 };
     };
 
-    static JuceVSTWrapper* getWrapper (Vst2::AEffect* v) noexcept  { return static_cast<JuceVSTWrapper*> (v->object); }
+    static JuceVSTWrapper* getWrapper (Vst2::VstEffectInterface* v) noexcept  { return static_cast<JuceVSTWrapper*> (v->effectPointer); }
 
     bool isProcessLevelOffline()
     {
         return hostCallback != nullptr
-                && (int32) hostCallback (&vstEffect, Vst2::audioMasterGetCurrentProcessLevel, 0, 0, nullptr, 0) == 4;
+                && (int32) hostCallback (&vstEffect, Vst2::hostOpcodeGetCurrentAudioProcessingLevel, 0, 0, nullptr, 0) == 4;
     }
 
     static int32 convertHexVersionToDecimal (const unsigned int hexVersion)
@@ -1447,8 +1439,8 @@ private:
         tmpBuffers.release();
 
         if (processor != nullptr)
-            tmpBuffers.tempChannels.insertMultiple (0, nullptr, vstEffect.numInputs
-                                                                 + vstEffect.numOutputs);
+            tmpBuffers.tempChannels.insertMultiple (0, nullptr, vstEffect.numInputChannels
+                                                                 + vstEffect.numOutputChannels);
     }
 
     void deleteTempChannels()
@@ -1612,7 +1604,7 @@ private:
         if (editorComp != nullptr)
         {
             editorComp->getEditorBounds (editorRect);
-            *((Vst2::ERect**) args.ptr) = &editorRect;
+            *((Vst2::VstEditorBounds**) args.ptr) = &editorRect;
             return (pointer_sized_int) &editorRect;
         }
 
@@ -1716,7 +1708,7 @@ private:
     pointer_sized_int handlePreAudioProcessingEvents (VstOpCodeArguments args)
     {
        #if JucePlugin_WantsMidiInput || JucePlugin_IsMidiEffect
-        VSTMidiEventList::addEventsToMidiBuffer ((Vst2::VstEvents*) args.ptr, midiEvents);
+        VSTMidiEventList::addEventsToMidiBuffer ((Vst2::VstEventBlock*) args.ptr, midiEvents);
         return 1;
        #else
         ignoreUnused (args);
@@ -1762,12 +1754,12 @@ private:
 
     pointer_sized_int handleGetInputPinProperties (VstOpCodeArguments args)
     {
-        return (processor != nullptr && getPinProperties (*(Vst2::VstPinProperties*) args.ptr, true, args.index)) ? 1 : 0;
+        return (processor != nullptr && getPinProperties (*(Vst2::VstPinInfo*) args.ptr, true, args.index)) ? 1 : 0;
     }
 
     pointer_sized_int handleGetOutputPinProperties (VstOpCodeArguments args)
     {
-        return (processor != nullptr && getPinProperties (*(Vst2::VstPinProperties*) args.ptr, false, args.index)) ? 1 : 0;
+        return (processor != nullptr && getPinProperties (*(Vst2::VstPinInfo*) args.ptr, false, args.index)) ? 1 : 0;
     }
 
     pointer_sized_int handleGetPlugInCategory (VstOpCodeArguments)
@@ -1777,8 +1769,8 @@ private:
 
     pointer_sized_int handleSetSpeakerConfiguration (VstOpCodeArguments args)
     {
-        auto* pluginInput  = reinterpret_cast<Vst2::VstSpeakerArrangement*> (args.value);
-        auto* pluginOutput = reinterpret_cast<Vst2::VstSpeakerArrangement*> (args.ptr);
+        auto* pluginInput  = reinterpret_cast<Vst2::VstSpeakerConfiguration*> (args.value);
+        auto* pluginOutput = reinterpret_cast<Vst2::VstSpeakerConfiguration*> (args.ptr);
 
         if (processor->isMidiEffect())
             return 0;
@@ -1789,29 +1781,29 @@ private:
         if (pluginInput != nullptr && pluginInput->type >= 0)
         {
             // inconsistent request?
-            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginInput).size() != pluginInput->numChannels)
+            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginInput).size() != pluginInput->numberOfChannels)
                 return 0;
         }
 
         if (pluginOutput != nullptr && pluginOutput->type >= 0)
         {
             // inconsistent request?
-            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginOutput).size() != pluginOutput->numChannels)
+            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginOutput).size() != pluginOutput->numberOfChannels)
                 return 0;
         }
 
-        if (pluginInput != nullptr  && pluginInput->numChannels  > 0 && numIns  == 0)
+        if (pluginInput != nullptr  && pluginInput->numberOfChannels  > 0 && numIns  == 0)
             return 0;
 
-        if (pluginOutput != nullptr && pluginOutput->numChannels > 0 && numOuts == 0)
+        if (pluginOutput != nullptr && pluginOutput->numberOfChannels > 0 && numOuts == 0)
             return 0;
 
         auto layouts = processor->getBusesLayout();
 
-        if (pluginInput != nullptr && pluginInput-> numChannels >= 0 && numIns  > 0)
+        if (pluginInput != nullptr && pluginInput-> numberOfChannels >= 0 && numIns  > 0)
             layouts.getChannelSet (true,  0) = SpeakerMappings::vstArrangementTypeToChannelSet (*pluginInput);
 
-        if (pluginOutput != nullptr && pluginOutput->numChannels >= 0 && numOuts > 0)
+        if (pluginOutput != nullptr && pluginOutput->numberOfChannels >= 0 && numOuts > 0)
             layouts.getChannelSet (false, 0) = SpeakerMappings::vstArrangementTypeToChannelSet (*pluginOutput);
 
        #ifdef JucePlugin_PreferredChannelConfigurations
@@ -1859,7 +1851,7 @@ private:
              && args.value == (int32) ByteOrder::bigEndianInt ("AeCs"))
             return handleSetContentScaleFactor (args.opt);
 
-        if (args.index == Vst2::effGetParamDisplay)
+        if (args.index == Vst2::plugInOpcodeGetParameterText)
             return handleCockosGetParameterText (args.value, args.ptr, args.opt);
 
         if (auto callbackHandler = dynamic_cast<VSTCallbackHandler*> (processor.get()))
@@ -1956,7 +1948,7 @@ private:
 
     pointer_sized_int handleGetVstInterfaceVersion (VstOpCodeArguments)
     {
-        return kVstVersion;
+        return Vst2::juceVstInterfaceVersion;
     }
 
     pointer_sized_int handleGetCurrentMidiProgram (VstOpCodeArguments)
@@ -1966,8 +1958,8 @@ private:
 
     pointer_sized_int handleGetSpeakerConfiguration (VstOpCodeArguments args)
     {
-        auto** pluginInput  = reinterpret_cast<Vst2::VstSpeakerArrangement**> (args.value);
-        auto** pluginOutput = reinterpret_cast<Vst2::VstSpeakerArrangement**> (args.ptr);
+        auto** pluginInput  = reinterpret_cast<Vst2::VstSpeakerConfiguration**> (args.value);
+        auto** pluginOutput = reinterpret_cast<Vst2::VstSpeakerConfiguration**> (args.ptr);
 
         if (pluginHasSidechainsOrAuxs() || processor->isMidiEffect())
             return false;
@@ -1975,10 +1967,10 @@ private:
         auto inputLayout  = processor->getChannelLayoutOfBus (true,  0);
         auto outputLayout = processor->getChannelLayoutOfBus (false,  0);
 
-        auto speakerBaseSize = sizeof (Vst2::VstSpeakerArrangement) - (sizeof (Vst2::VstSpeakerProperties) * 8);
+        auto speakerBaseSize = sizeof (Vst2::VstSpeakerConfiguration) - (sizeof (Vst2::VstIndividualSpeakerInfo) * 8);
 
-        cachedInArrangement .malloc (speakerBaseSize + (static_cast<std::size_t> (inputLayout. size()) * sizeof (Vst2::VstSpeakerArrangement)), 1);
-        cachedOutArrangement.malloc (speakerBaseSize + (static_cast<std::size_t> (outputLayout.size()) * sizeof (Vst2::VstSpeakerArrangement)), 1);
+        cachedInArrangement .malloc (speakerBaseSize + (static_cast<std::size_t> (inputLayout. size()) * sizeof (Vst2::VstSpeakerConfiguration)), 1);
+        cachedOutArrangement.malloc (speakerBaseSize + (static_cast<std::size_t> (outputLayout.size()) * sizeof (Vst2::VstSpeakerConfiguration)), 1);
 
         *pluginInput  = cachedInArrangement. getData();
         *pluginOutput = cachedOutArrangement.getData();
@@ -2000,7 +1992,7 @@ private:
         {
             if (processor != nullptr)
             {
-                processor->setProcessingPrecision ((args.value == Vst2::kVstProcessPrecision64
+                processor->setProcessingPrecision ((args.value == Vst2::vstProcessingSampleTypeDouble
                                                      && processor->supportsDoublePrecisionProcessing())
                                                          ? AudioProcessor::doublePrecision
                                                          : AudioProcessor::singlePrecision);
@@ -2101,17 +2093,17 @@ private:
     SharedResourcePointer<MessageThread> messageThread;
    #endif
 
-    Vst2::audioMasterCallback hostCallback;
+    Vst2::VstHostCallback hostCallback;
     std::unique_ptr<AudioProcessor> processor;
     double sampleRate = 44100.0;
     int32 blockSize = 1024;
-    Vst2::AEffect vstEffect;
+    Vst2::VstEffectInterface vstEffect;
     CriticalSection stateInformationLock;
     juce::MemoryBlock chunkMemory;
     uint32 chunkMemoryTime = 0;
     float editorScaleFactor = 1.0f;
     std::unique_ptr<EditorCompWrapper> editorComp;
-    Vst2::ERect editorRect;
+    Vst2::VstEditorBounds editorRect;
     MidiBuffer midiEvents;
     VSTMidiEventList outgoingEvents;
     Optional<PositionInfo> currentPosition;
@@ -2133,7 +2125,7 @@ private:
     VstTempBuffers<double> doubleTempBuffers;
     int maxNumInChannels = 0, maxNumOutChannels = 0;
 
-    HeapBlock<Vst2::VstSpeakerArrangement> cachedInArrangement, cachedOutArrangement;
+    HeapBlock<Vst2::VstSpeakerConfiguration> cachedInArrangement, cachedOutArrangement;
 
     ThreadLocalValue<bool> inParameterChangedCallback;
 
@@ -2147,7 +2139,7 @@ private:
 //==============================================================================
 namespace
 {
-    Vst2::AEffect* pluginEntryPoint (Vst2::audioMasterCallback audioMaster)
+    Vst2::VstEffectInterface* pluginEntryPoint (Vst2::VstHostCallback audioMaster)
     {
         JUCE_AUTORELEASEPOOL
         {
@@ -2159,7 +2151,7 @@ namespace
 
             try
             {
-                if (audioMaster (nullptr, Vst2::audioMasterVersion, 0, 0, nullptr, 0) != 0)
+                if (audioMaster (nullptr, Vst2::hostOpcodeVstVersion, 0, 0, nullptr, 0) != 0)
                 {
                     std::unique_ptr<AudioProcessor> processor { createPluginFilterOfType (AudioProcessor::wrapperType_VST) };
                     auto* processorPtr = processor.get();
@@ -2195,8 +2187,8 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wmissing-prototypes")
 // Mac startup code..
 #if JUCE_MAC
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster);
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster);
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2204,8 +2196,8 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wmissing-prototypes")
         return pluginEntryPoint (audioMaster);
     }
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_macho (Vst2::audioMasterCallback audioMaster);
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_macho (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_macho (Vst2::VstHostCallback audioMaster);
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_macho (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2217,16 +2209,16 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wmissing-prototypes")
 // Linux startup code..
 #elif JUCE_LINUX || JUCE_BSD
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster);
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster);
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
         return pluginEntryPoint (audioMaster);
     }
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_plugin (Vst2::audioMasterCallback audioMaster) asm ("main");
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_plugin (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_plugin (Vst2::VstHostCallback audioMaster) asm ("main");
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_plugin (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2241,7 +2233,7 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wmissing-prototypes")
 // Win32 startup code..
 #else
 
-    extern "C" __declspec (dllexport) Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster)
+    extern "C" __declspec (dllexport) Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2249,7 +2241,7 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wmissing-prototypes")
     }
 
    #if ! defined (JUCE_64BIT) && JUCE_MSVC // (can't compile this on win64, but it's not needed anyway with VST2.4)
-    extern "C" __declspec (dllexport) int main (Vst2::audioMasterCallback audioMaster)
+    extern "C" __declspec (dllexport) int main (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
diff --git a/modules/juce_audio_plugin_client/VST3/juce_VST3_Wrapper.cpp b/modules/juce_audio_plugin_client/VST3/juce_VST3_Wrapper.cpp
index 1e77dee85..fbbbb6658 100644
--- a/modules/juce_audio_plugin_client/VST3/juce_VST3_Wrapper.cpp
+++ b/modules/juce_audio_plugin_client/VST3/juce_VST3_Wrapper.cpp
@@ -65,8 +65,7 @@ JUCE_BEGIN_NO_SANITIZE ("vptr")
 
  namespace Vst2
  {
- struct AEffect;
- #include "pluginterfaces/vst2.x/vstfxstore.h"
+ #include "../../juce_audio_processors/format_types/juce_VSTInterface.h"
  }
 
 #endif
@@ -2620,16 +2619,16 @@ public:
 
     bool loadVST2CcnKBlock (const char* data, int size)
     {
-        auto* bank = reinterpret_cast<const Vst2::fxBank*> (data);
+        auto* bank = reinterpret_cast<const Vst2::vst2FxBank*> (data);
 
-        jassert (ByteOrder::bigEndianInt ("CcnK") == htonl ((uint32) bank->chunkMagic));
-        jassert (ByteOrder::bigEndianInt ("FBCh") == htonl ((uint32) bank->fxMagic));
-        jassert (htonl ((uint32) bank->version) == 1 || htonl ((uint32) bank->version) == 2);
+        jassert (ByteOrder::bigEndianInt ("CcnK") == htonl ((uint32) bank->magic1));
+        jassert (ByteOrder::bigEndianInt ("FBCh") == htonl ((uint32) bank->magic2));
+        jassert (htonl ((uint32) bank->version1) == 1 || htonl ((uint32) bank->version1) == 2);
         jassert (JucePlugin_VSTUniqueID == htonl ((uint32) bank->fxID));
 
-        setStateInformation (bank->content.data.chunk,
-                             jmin ((int) (size - (bank->content.data.chunk - data)),
-                                   (int) htonl ((uint32) bank->content.data.size)));
+        setStateInformation (bank->chunk,
+                             jmin ((int) (size - (bank->chunk - data)),
+                                   (int) htonl ((uint32) bank->chunkSize)));
         return true;
     }
 
@@ -2829,16 +2828,16 @@ public:
             return status;
 
         const int bankBlockSize = 160;
-        Vst2::fxBank bank;
+        Vst2::vst2FxBank bank;
 
         zerostruct (bank);
-        bank.chunkMagic         = (int32) htonl (ByteOrder::bigEndianInt ("CcnK"));
-        bank.byteSize           = (int32) htonl (bankBlockSize - 8 + (unsigned int) mem.getSize());
-        bank.fxMagic            = (int32) htonl (ByteOrder::bigEndianInt ("FBCh"));
-        bank.version            = (int32) htonl (2);
-        bank.fxID               = (int32) htonl (JucePlugin_VSTUniqueID);
-        bank.fxVersion          = (int32) htonl (JucePlugin_VersionCode);
-        bank.content.data.size  = (int32) htonl ((unsigned int) mem.getSize());
+        bank.magic1     = (int32) htonl (ByteOrder::bigEndianInt ("CcnK"));
+        bank.size       = (int32) htonl (bankBlockSize - 8 + (unsigned int) mem.getSize());
+        bank.magic2     = (int32) htonl (ByteOrder::bigEndianInt ("FBCh"));
+        bank.version1   = (int32) htonl (2);
+        bank.fxID       = (int32) htonl (JucePlugin_VSTUniqueID);
+        bank.version2   = (int32) htonl (JucePlugin_VersionCode);
+        bank.chunkSize  = (int32) htonl ((unsigned int) mem.getSize());
 
         status = state->write (&bank, bankBlockSize);
 
diff --git a/modules/juce_audio_processors/format_types/juce_VSTCommon.h b/modules/juce_audio_processors/format_types/juce_VSTCommon.h
index 851eef996..6c1f42dba 100644
--- a/modules/juce_audio_processors/format_types/juce_VSTCommon.h
+++ b/modules/juce_audio_processors/format_types/juce_VSTCommon.h
@@ -58,25 +58,25 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
 
     static AudioChannelSet vstArrangementTypeToChannelSet (int32 arr, int fallbackNumChannels)
     {
-        if      (arr == Vst2::kSpeakerArrEmpty)        return AudioChannelSet::disabled();
-        else if (arr == Vst2::kSpeakerArrMono)         return AudioChannelSet::mono();
-        else if (arr == Vst2::kSpeakerArrStereo)       return AudioChannelSet::stereo();
-        else if (arr == Vst2::kSpeakerArr30Cine)       return AudioChannelSet::createLCR();
-        else if (arr == Vst2::kSpeakerArr30Music)      return AudioChannelSet::createLRS();
-        else if (arr == Vst2::kSpeakerArr40Cine)       return AudioChannelSet::createLCRS();
-        else if (arr == Vst2::kSpeakerArr50)           return AudioChannelSet::create5point0();
-        else if (arr == Vst2::kSpeakerArr51)           return AudioChannelSet::create5point1();
-        else if (arr == Vst2::kSpeakerArr60Cine)       return AudioChannelSet::create6point0();
-        else if (arr == Vst2::kSpeakerArr61Cine)       return AudioChannelSet::create6point1();
-        else if (arr == Vst2::kSpeakerArr60Music)      return AudioChannelSet::create6point0Music();
-        else if (arr == Vst2::kSpeakerArr61Music)      return AudioChannelSet::create6point1Music();
-        else if (arr == Vst2::kSpeakerArr70Music)      return AudioChannelSet::create7point0();
-        else if (arr == Vst2::kSpeakerArr70Cine)       return AudioChannelSet::create7point0SDDS();
-        else if (arr == Vst2::kSpeakerArr71Music)      return AudioChannelSet::create7point1();
-        else if (arr == Vst2::kSpeakerArr71Cine)       return AudioChannelSet::create7point1SDDS();
-        else if (arr == Vst2::kSpeakerArr40Music)      return AudioChannelSet::quadraphonic();
-
-        for (const Mapping* m = getMappings(); m->vst2 != Vst2::kSpeakerArrEmpty; ++m)
+        if      (arr == Vst2::vstSpeakerConfigTypeEmpty)          return AudioChannelSet::disabled();
+        else if (arr == Vst2::vstSpeakerConfigTypeMono)           return AudioChannelSet::mono();
+        else if (arr == Vst2::vstSpeakerConfigTypeLR)             return AudioChannelSet::stereo();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRC)            return AudioChannelSet::createLCR();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRS)            return AudioChannelSet::createLRS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCS)           return AudioChannelSet::createLCRS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRs)        return AudioChannelSet::create5point0();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRs)     return AudioChannelSet::create5point1();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRsCs)      return AudioChannelSet::create6point0();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRsCs)   return AudioChannelSet::create6point1();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRLsRsSlSr)     return AudioChannelSet::create6point0Music();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRLfeLsRsSlSr)  return AudioChannelSet::create6point1Music();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRsSlSr)    return AudioChannelSet::create7point0();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRsLcRc)    return AudioChannelSet::create7point0SDDS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRsSlSr) return AudioChannelSet::create7point1();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRc) return AudioChannelSet::create7point1SDDS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRLsRs)         return AudioChannelSet::quadraphonic();
+
+        for (const Mapping* m = getMappings(); m->vst2 != Vst2::vstSpeakerConfigTypeEmpty; ++m)
         {
             if (m->vst2 == arr)
             {
@@ -92,53 +92,53 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
         return AudioChannelSet::discreteChannels (fallbackNumChannels);
     }
 
-    static AudioChannelSet vstArrangementTypeToChannelSet (const Vst2::VstSpeakerArrangement& arr)
+    static AudioChannelSet vstArrangementTypeToChannelSet (const Vst2::VstSpeakerConfiguration& arr)
     {
-        return vstArrangementTypeToChannelSet (arr.type, arr.numChannels);
+        return vstArrangementTypeToChannelSet (arr.type, arr.numberOfChannels);
     }
 
     static int32 channelSetToVstArrangementType (AudioChannelSet channels)
     {
-        if      (channels == AudioChannelSet::disabled())           return Vst2::kSpeakerArrEmpty;
-        else if (channels == AudioChannelSet::mono())               return Vst2::kSpeakerArrMono;
-        else if (channels == AudioChannelSet::stereo())             return Vst2::kSpeakerArrStereo;
-        else if (channels == AudioChannelSet::createLCR())          return Vst2::kSpeakerArr30Cine;
-        else if (channels == AudioChannelSet::createLRS())          return Vst2::kSpeakerArr30Music;
-        else if (channels == AudioChannelSet::createLCRS())         return Vst2::kSpeakerArr40Cine;
-        else if (channels == AudioChannelSet::create5point0())      return Vst2::kSpeakerArr50;
-        else if (channels == AudioChannelSet::create5point1())      return Vst2::kSpeakerArr51;
-        else if (channels == AudioChannelSet::create6point0())      return Vst2::kSpeakerArr60Cine;
-        else if (channels == AudioChannelSet::create6point1())      return Vst2::kSpeakerArr61Cine;
-        else if (channels == AudioChannelSet::create6point0Music()) return Vst2::kSpeakerArr60Music;
-        else if (channels == AudioChannelSet::create6point1Music()) return Vst2::kSpeakerArr61Music;
-        else if (channels == AudioChannelSet::create7point0())      return Vst2::kSpeakerArr70Music;
-        else if (channels == AudioChannelSet::create7point0SDDS())  return Vst2::kSpeakerArr70Cine;
-        else if (channels == AudioChannelSet::create7point1())      return Vst2::kSpeakerArr71Music;
-        else if (channels == AudioChannelSet::create7point1SDDS())  return Vst2::kSpeakerArr71Cine;
-        else if (channels == AudioChannelSet::quadraphonic())       return Vst2::kSpeakerArr40Music;
+        if      (channels == AudioChannelSet::disabled())           return Vst2::vstSpeakerConfigTypeEmpty;
+        else if (channels == AudioChannelSet::mono())               return Vst2::vstSpeakerConfigTypeMono;
+        else if (channels == AudioChannelSet::stereo())             return Vst2::vstSpeakerConfigTypeLR;
+        else if (channels == AudioChannelSet::createLCR())          return Vst2::vstSpeakerConfigTypeLRC;
+        else if (channels == AudioChannelSet::createLRS())          return Vst2::vstSpeakerConfigTypeLRS;
+        else if (channels == AudioChannelSet::createLCRS())         return Vst2::vstSpeakerConfigTypeLRCS;
+        else if (channels == AudioChannelSet::create5point0())      return Vst2::vstSpeakerConfigTypeLRCLsRs;
+        else if (channels == AudioChannelSet::create5point1())      return Vst2::vstSpeakerConfigTypeLRCLfeLsRs;
+        else if (channels == AudioChannelSet::create6point0())      return Vst2::vstSpeakerConfigTypeLRCLsRsCs;
+        else if (channels == AudioChannelSet::create6point1())      return Vst2::vstSpeakerConfigTypeLRCLfeLsRsCs;
+        else if (channels == AudioChannelSet::create6point0Music()) return Vst2::vstSpeakerConfigTypeLRLsRsSlSr;
+        else if (channels == AudioChannelSet::create6point1Music()) return Vst2::vstSpeakerConfigTypeLRLfeLsRsSlSr;
+        else if (channels == AudioChannelSet::create7point0())      return Vst2::vstSpeakerConfigTypeLRCLsRsSlSr;
+        else if (channels == AudioChannelSet::create7point0SDDS())  return Vst2::vstSpeakerConfigTypeLRCLsRsLcRc;
+        else if (channels == AudioChannelSet::create7point1())      return Vst2::vstSpeakerConfigTypeLRCLfeLsRsSlSr;
+        else if (channels == AudioChannelSet::create7point1SDDS())  return Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRc;
+        else if (channels == AudioChannelSet::quadraphonic())       return Vst2::vstSpeakerConfigTypeLRLsRs;
 
         if (channels == AudioChannelSet::disabled())
-            return Vst2::kSpeakerArrEmpty;
+            return Vst2::vstSpeakerConfigTypeEmpty;
 
         auto chans = channels.getChannelTypes();
 
-        for (auto* m = getMappings(); m->vst2 != Vst2::kSpeakerArrEmpty; ++m)
+        for (auto* m = getMappings(); m->vst2 != Vst2::vstSpeakerConfigTypeEmpty; ++m)
             if (m->matches (chans))
                 return m->vst2;
 
-        return Vst2::kSpeakerArrUserDefined;
+        return Vst2::vstSpeakerConfigTypeUser;
     }
 
-    static void channelSetToVstArrangement (const AudioChannelSet& channels, Vst2::VstSpeakerArrangement& result)
+    static void channelSetToVstArrangement (const AudioChannelSet& channels, Vst2::VstSpeakerConfiguration& result)
     {
         result.type = channelSetToVstArrangementType (channels);
-        result.numChannels = channels.size();
+        result.numberOfChannels = channels.size();
 
-        for (int i = 0; i < result.numChannels; ++i)
+        for (int i = 0; i < result.numberOfChannels; ++i)
         {
             auto& speaker = result.speakers[i];
 
-            zeromem (&speaker, sizeof (Vst2::VstSpeakerProperties));
+            zeromem (&speaker, sizeof (Vst2::VstIndividualSpeakerInfo));
             speaker.type = getSpeakerType (channels.getTypeOfChannel (i));
         }
     }
@@ -152,7 +152,7 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
             clear();
         }
 
-        VstSpeakerConfigurationHolder (const Vst2::VstSpeakerArrangement& vstConfig)
+        VstSpeakerConfigurationHolder (const Vst2::VstSpeakerConfiguration& vstConfig)
         {
             operator= (vstConfig);
         }
@@ -171,29 +171,29 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
         VstSpeakerConfigurationHolder (const AudioChannelSet& channels)
         {
             auto numberOfChannels = channels.size();
-            Vst2::VstSpeakerArrangement& dst = *allocate (numberOfChannels);
+            Vst2::VstSpeakerConfiguration& dst = *allocate (numberOfChannels);
 
             dst.type = channelSetToVstArrangementType (channels);
-            dst.numChannels = numberOfChannels;
+            dst.numberOfChannels = numberOfChannels;
 
-            for (int i = 0; i < dst.numChannels; ++i)
+            for (int i = 0; i < dst.numberOfChannels; ++i)
             {
-                Vst2::VstSpeakerProperties& speaker = dst.speakers[i];
+                Vst2::VstIndividualSpeakerInfo& speaker = dst.speakers[i];
 
-                zeromem (&speaker, sizeof (Vst2::VstSpeakerProperties));
+                zeromem (&speaker, sizeof (Vst2::VstIndividualSpeakerInfo));
                 speaker.type = getSpeakerType (channels.getTypeOfChannel (i));
             }
         }
 
         VstSpeakerConfigurationHolder& operator= (const VstSpeakerConfigurationHolder& vstConfig) { return operator=(vstConfig.get()); }
-        VstSpeakerConfigurationHolder& operator= (const Vst2::VstSpeakerArrangement& vstConfig)
+        VstSpeakerConfigurationHolder& operator= (const Vst2::VstSpeakerConfiguration& vstConfig)
         {
-            Vst2::VstSpeakerArrangement& dst = *allocate (vstConfig.numChannels);
+            Vst2::VstSpeakerConfiguration& dst = *allocate (vstConfig.numberOfChannels);
 
             dst.type             = vstConfig.type;
-            dst.numChannels      = vstConfig.numChannels;
+            dst.numberOfChannels = vstConfig.numberOfChannels;
 
-            for (int i = 0; i < dst.numChannels; ++i)
+            for (int i = 0; i < dst.numberOfChannels; ++i)
                 dst.speakers[i] = vstConfig.speakers[i];
 
             return *this;
@@ -207,17 +207,17 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
             return *this;
         }
 
-        const Vst2::VstSpeakerArrangement& get() const { return *storage.get(); }
+        const Vst2::VstSpeakerConfiguration& get() const { return *storage.get(); }
 
     private:
         JUCE_LEAK_DETECTOR (VstSpeakerConfigurationHolder)
 
-        HeapBlock<Vst2::VstSpeakerArrangement> storage;
+        HeapBlock<Vst2::VstSpeakerConfiguration> storage;
 
-        Vst2::VstSpeakerArrangement* allocate (int numChannels)
+        Vst2::VstSpeakerConfiguration* allocate (int numChannels)
         {
-            auto arrangementSize = (size_t) (jmax (8, numChannels) - 8) * sizeof (Vst2::VstSpeakerProperties)
-                                    + sizeof (Vst2::VstSpeakerArrangement);
+            auto arrangementSize = (size_t) (jmax (8, numChannels) - 8) * sizeof (Vst2::VstIndividualSpeakerInfo)
+                                    + sizeof (Vst2::VstSpeakerConfiguration);
 
             storage.malloc (1, arrangementSize);
             return storage.get();
@@ -225,10 +225,10 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
 
         void clear()
         {
-            Vst2::VstSpeakerArrangement& dst = *allocate (0);
+            Vst2::VstSpeakerConfiguration& dst = *allocate (0);
 
-            dst.type = Vst2::kSpeakerArrEmpty;
-            dst.numChannels = 0;
+            dst.type = Vst2::vstSpeakerConfigTypeEmpty;
+            dst.numberOfChannels = 0;
         }
     };
 
@@ -236,36 +236,36 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
     {
         static const Mapping mappings[] =
         {
-            { Vst2::kSpeakerArrMono,           { centre, unknown } },
-            { Vst2::kSpeakerArrStereo,         { left, right, unknown } },
-            { Vst2::kSpeakerArrStereoSurround, { leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArrStereoCenter,   { leftCentre, rightCentre, unknown } },
-            { Vst2::kSpeakerArrStereoSide,     { leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArrStereoCLfe,     { centre, LFE, unknown } },
-            { Vst2::kSpeakerArr30Cine,         { left, right, centre, unknown } },
-            { Vst2::kSpeakerArr30Music,        { left, right, surround, unknown } },
-            { Vst2::kSpeakerArr31Cine,         { left, right, centre, LFE, unknown } },
-            { Vst2::kSpeakerArr31Music,        { left, right, LFE, surround, unknown } },
-            { Vst2::kSpeakerArr40Cine,         { left, right, centre, surround, unknown } },
-            { Vst2::kSpeakerArr40Music,        { left, right, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr41Cine,         { left, right, centre, LFE, surround, unknown } },
-            { Vst2::kSpeakerArr41Music,        { left, right, LFE, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr50,             { left, right, centre, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr51,             { left, right, centre, LFE, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr60Cine,         { left, right, centre, leftSurround, rightSurround, surround, unknown } },
-            { Vst2::kSpeakerArr60Music,        { left, right, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr61Cine,         { left, right, centre, LFE, leftSurround, rightSurround, surround, unknown } },
-            { Vst2::kSpeakerArr61Music,        { left, right, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr70Cine,         { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
-            { Vst2::kSpeakerArr70Music,        { left, right, centre, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr71Cine,         { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
-            { Vst2::kSpeakerArr71Music,        { left, right, centre, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr80Cine,         { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
-            { Vst2::kSpeakerArr80Music,        { left, right, centre, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr81Cine,         { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
-            { Vst2::kSpeakerArr81Music,        { left, right, centre, LFE, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr102,            { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontCentre, topFrontRight, topRearLeft, topRearRight, LFE2, unknown } },
-            { Vst2::kSpeakerArrEmpty,          { unknown } }
+            { Vst2::vstSpeakerConfigTypeMono,                          { centre, unknown } },
+            { Vst2::vstSpeakerConfigTypeLR,                            { left, right, unknown } },
+            { Vst2::vstSpeakerConfigTypeLsRs,                          { leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLcRc,                          { leftCentre, rightCentre, unknown } },
+            { Vst2::vstSpeakerConfigTypeSlSr,                          { leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeCLfe,                          { centre, LFE, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRC,                           { left, right, centre, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRS,                           { left, right, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfe,                        { left, right, centre, LFE, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLfeS,                        { left, right, LFE, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCS,                          { left, right, centre, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLsRs,                        { left, right, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeS,                       { left, right, centre, LFE, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLfeLsRs,                     { left, right, LFE, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRs,                       { left, right, centre, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRs,                    { left, right, centre, LFE, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsCs,                     { left, right, centre, leftSurround, rightSurround, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLsRsSlSr,                    { left, right, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsCs,                  { left, right, centre, LFE, leftSurround, rightSurround, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLfeLsRsSlSr,                 { left, right, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsLcRc,                   { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsSlSr,                   { left, right, centre, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRc,                { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsSlSr,                { left, right, centre, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsLcRcCs,                 { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsCsSlSr,                 { left, right, centre, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRcCs,              { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsCsSlSr,              { left, right, centre, LFE, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsTflTfcTfrTrlTrrLfe2, { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontCentre, topFrontRight, topRearLeft, topRearRight, LFE2, unknown } },
+            { Vst2::vstSpeakerConfigTypeEmpty,                         { unknown } }
         };
 
         return mappings;
@@ -275,25 +275,25 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
     {
         static const std::map<AudioChannelSet::ChannelType, int32> speakerTypeMap =
         {
-            { AudioChannelSet::left,              Vst2::kSpeakerL },
-            { AudioChannelSet::right,             Vst2::kSpeakerR },
-            { AudioChannelSet::centre,            Vst2::kSpeakerC },
-            { AudioChannelSet::LFE,               Vst2::kSpeakerLfe },
-            { AudioChannelSet::leftSurround,      Vst2::kSpeakerLs },
-            { AudioChannelSet::rightSurround,     Vst2::kSpeakerRs },
-            { AudioChannelSet::leftCentre,        Vst2::kSpeakerLc },
-            { AudioChannelSet::rightCentre,       Vst2::kSpeakerRc },
-            { AudioChannelSet::surround,          Vst2::kSpeakerS },
-            { AudioChannelSet::leftSurroundRear,  Vst2::kSpeakerSl },
-            { AudioChannelSet::rightSurroundRear, Vst2::kSpeakerSr },
-            { AudioChannelSet::topMiddle,         Vst2::kSpeakerTm },
-            { AudioChannelSet::topFrontLeft,      Vst2::kSpeakerTfl },
-            { AudioChannelSet::topFrontCentre,    Vst2::kSpeakerTfc },
-            { AudioChannelSet::topFrontRight,     Vst2::kSpeakerTfr },
-            { AudioChannelSet::topRearLeft,       Vst2::kSpeakerTrl },
-            { AudioChannelSet::topRearCentre,     Vst2::kSpeakerTrc },
-            { AudioChannelSet::topRearRight,      Vst2::kSpeakerTrr },
-            { AudioChannelSet::LFE2,              Vst2::kSpeakerLfe2 }
+            { AudioChannelSet::left,              Vst2::vstIndividualSpeakerTypeLeft },
+            { AudioChannelSet::right,             Vst2::vstIndividualSpeakerTypeRight },
+            { AudioChannelSet::centre,            Vst2::vstIndividualSpeakerTypeCentre },
+            { AudioChannelSet::LFE,               Vst2::vstIndividualSpeakerTypeLFE },
+            { AudioChannelSet::leftSurround,      Vst2::vstIndividualSpeakerTypeLeftSurround },
+            { AudioChannelSet::rightSurround,     Vst2::vstIndividualSpeakerTypeRightSurround },
+            { AudioChannelSet::leftCentre,        Vst2::vstIndividualSpeakerTypeLeftCentre },
+            { AudioChannelSet::rightCentre,       Vst2::vstIndividualSpeakerTypeRightCentre },
+            { AudioChannelSet::surround,          Vst2::vstIndividualSpeakerTypeSurround },
+            { AudioChannelSet::leftSurroundRear,  Vst2::vstIndividualSpeakerTypeLeftRearSurround },
+            { AudioChannelSet::rightSurroundRear, Vst2::vstIndividualSpeakerTypeRightRearSurround },
+            { AudioChannelSet::topMiddle,         Vst2::vstIndividualSpeakerTypeTopMiddle },
+            { AudioChannelSet::topFrontLeft,      Vst2::vstIndividualSpeakerTypeTopFrontLeft },
+            { AudioChannelSet::topFrontCentre,    Vst2::vstIndividualSpeakerTypeTopFrontCentre },
+            { AudioChannelSet::topFrontRight,     Vst2::vstIndividualSpeakerTypeTopFrontRight },
+            { AudioChannelSet::topRearLeft,       Vst2::vstIndividualSpeakerTypeTopRearLeft },
+            { AudioChannelSet::topRearCentre,     Vst2::vstIndividualSpeakerTypeTopRearCentre },
+            { AudioChannelSet::topRearRight,      Vst2::vstIndividualSpeakerTypeTopRearRight },
+            { AudioChannelSet::LFE2,              Vst2::vstIndividualSpeakerTypeLFE2 }
         };
 
         if (speakerTypeMap.find (type) == speakerTypeMap.end())
diff --git a/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h b/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h
index 64cb52f0e..10157693f 100644
--- a/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h
+++ b/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h
@@ -23,8 +23,12 @@
   ==============================================================================
 */
 
-// NB: this must come first, *before* the header-guard.
-#ifdef JUCE_VSTINTERFACE_H_INCLUDED
+#pragma once
+
+namespace Vst2
+{
+#include "juce_VSTInterface.h"
+}
 
 namespace juce
 {
@@ -39,7 +43,7 @@ namespace juce
 */
 class VSTMidiEventList
 {
-    // "events" is expected to be a const- or non-const-ref to Vst2::VstEvents.
+    // "events" is expected to be a const- or non-const-ref to Vst2::VstEventBlock.
     template <typename Events>
     static auto& getEvent (Events& events, int index)
     {
@@ -73,7 +77,7 @@ public:
         numEventsUsed = 0;
 
         if (events != nullptr)
-            events->numEvents = 0;
+            events->numberOfEvents = 0;
     }
 
     void addEvent (const void* const midiData, int numBytes, int frameOffset)
@@ -81,52 +85,52 @@ public:
         ensureSize (numEventsUsed + 1);
 
         void* const ptr = getEvent (numEventsUsed);
-        events->numEvents = ++numEventsUsed;
+        events->numberOfEvents = ++numEventsUsed;
 
         if (numBytes <= 4)
         {
             auto* const e = static_cast<Vst2::VstMidiEvent*> (ptr);
 
-            if (e->type == Vst2::kVstSysExType)
+            if (e->type == Vst2::vstSysExEventType)
             {
-                delete[] reinterpret_cast<Vst2::VstMidiSysexEvent*> (e)->sysexDump;
-                e->type = Vst2::kVstMidiType;
-                e->byteSize = sizeof (Vst2::VstMidiEvent);
-                e->noteLength = 0;
-                e->noteOffset = 0;
-                e->detune = 0;
-                e->noteOffVelocity = 0;
+                delete[] reinterpret_cast<Vst2::VstSysExEvent*> (e)->sysExDump;
+                e->type = Vst2::vstMidiEventType;
+                e->size = sizeof (Vst2::VstMidiEvent);
+                e->noteSampleLength = 0;
+                e->noteSampleOffset = 0;
+                e->tuning = 0;
+                e->noteVelocityOff = 0;
             }
 
-            e->deltaFrames = frameOffset;
+            e->sampleOffset = frameOffset;
             memcpy (e->midiData, midiData, (size_t) numBytes);
         }
         else
         {
-            auto* const se = static_cast<Vst2::VstMidiSysexEvent*> (ptr);
+            auto* const se = static_cast<Vst2::VstSysExEvent*> (ptr);
 
-            if (se->type == Vst2::kVstSysExType)
-                delete[] se->sysexDump;
+            if (se->type == Vst2::vstSysExEventType)
+                delete[] se->sysExDump;
 
-            se->sysexDump = new char [(size_t) numBytes];
-            memcpy (se->sysexDump, midiData, (size_t) numBytes);
+            se->sysExDump = new char [(size_t) numBytes];
+            memcpy (se->sysExDump, midiData, (size_t) numBytes);
 
-            se->type = Vst2::kVstSysExType;
-            se->byteSize = sizeof (Vst2::VstMidiSysexEvent);
-            se->deltaFrames = frameOffset;
+            se->type = Vst2::vstSysExEventType;
+            se->size = sizeof (Vst2::VstSysExEvent);
+            se->offsetSamples = frameOffset;
             se->flags = 0;
-            se->dumpBytes = numBytes;
-            se->resvd1 = 0;
-            se->resvd2 = 0;
+            se->sysExDumpSize = numBytes;
+            se->future1 = 0;
+            se->future2 = 0;
         }
     }
 
     //==============================================================================
     // Handy method to pull the events out of an event buffer supplied by the host
     // or plugin.
-    static void addEventsToMidiBuffer (const Vst2::VstEvents* events, MidiBuffer& dest)
+    static void addEventsToMidiBuffer (const Vst2::VstEventBlock* events, MidiBuffer& dest)
     {
-        for (int i = 0; i < events->numEvents; ++i)
+        for (int i = 0; i < events->numberOfEvents; ++i)
         {
             const auto* const e = getEvent (*events, i);
 
@@ -134,17 +138,17 @@ public:
             {
                 const void* const ptr = e;
 
-                if (e->type == Vst2::kVstMidiType)
+                if (e->type == Vst2::vstMidiEventType)
                 {
                     dest.addEvent ((const juce::uint8*) static_cast<const Vst2::VstMidiEvent*> (ptr)->midiData,
-                                   4, e->deltaFrames);
+                                   4, e->sampleOffset);
                 }
-                else if (e->type == Vst2::kVstSysExType)
+                else if (e->type == Vst2::vstSysExEventType)
                 {
-                    const auto* se = static_cast<const Vst2::VstMidiSysexEvent*> (ptr);
-                    dest.addEvent ((const juce::uint8*) se->sysexDump,
-                                   (int) se->dumpBytes,
-                                   e->deltaFrames);
+                    const auto* se = static_cast<const Vst2::VstSysExEvent*> (ptr);
+                    dest.addEvent ((const juce::uint8*) se->sysExDump,
+                                   (int) se->sysExDumpSize,
+                                   e->sampleOffset);
                 }
             }
         }
@@ -185,19 +189,19 @@ public:
     }
 
     //==============================================================================
-    HeapBlock<Vst2::VstEvents> events;
+    HeapBlock<Vst2::VstEventBlock> events;
 
 private:
     int numEventsUsed, numEventsAllocated;
 
     static Vst2::VstEvent* allocateVSTEvent()
     {
-        constexpr auto size = jmax (sizeof (Vst2::VstMidiEvent), sizeof (Vst2::VstMidiSysexEvent));
+        constexpr auto size = jmax (sizeof (Vst2::VstMidiEvent), sizeof (Vst2::VstSysExEvent));
 
         if (auto* e = static_cast<Vst2::VstEvent*> (std::calloc (1, size)))
         {
-            e->type = Vst2::kVstMidiType;
-            e->byteSize = sizeof (Vst2::VstMidiEvent);
+            e->type = Vst2::vstMidiEventType;
+            e->size = sizeof (Vst2::VstMidiEvent);
             return e;
         }
 
@@ -206,9 +210,9 @@ private:
 
     static void freeVSTEvent (Vst2::VstEvent* e)
     {
-        if (e->type == Vst2::kVstSysExType)
+        if (e->type == Vst2::vstSysExEventType)
         {
-            delete[] (reinterpret_cast<Vst2::VstMidiSysexEvent*> (e)->sysexDump);
+            delete[] (reinterpret_cast<Vst2::VstSysExEvent*> (e)->sysExDump);
         }
 
         std::free (e);
@@ -216,5 +220,3 @@ private:
 };
 
 } // namespace juce
-
-#endif // JUCE_VSTINTERFACE_H_INCLUDED
diff --git a/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp b/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp
index 499c39ccb..f3a3ba2f8 100644
--- a/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp
+++ b/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp
@@ -37,19 +37,10 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wzero-as-null-pointer-constant")
 JUCE_BEGIN_IGNORE_WARNINGS_MSVC (4996)
 
 #define VST_FORCE_DEPRECATED 0
-#define JUCE_VSTINTERFACE_H_INCLUDED 1
 
 namespace Vst2
 {
-struct AEffect;
-
-// If the following files cannot be found then you are probably trying to host
-// VST2 plug-ins. To do this you must have a VST2 SDK in your header search
-// paths or use the "VST (Legacy) SDK Folder" field in the Projucer. The VST2
-// SDK can be obtained from the vstsdk3610_11_06_2018_build_37 (or older) VST3
-// SDK or JUCE version 5.3.2.
-#include <pluginterfaces/vst2.x/aeffect.h>
-#include <pluginterfaces/vst2.x/aeffectx.h>
+#include "juce_VSTInterface.h"
 }
 
 #include "juce_VSTCommon.h"
@@ -79,7 +70,7 @@ JUCE_BEGIN_IGNORE_WARNINGS_MSVC (4355)
 #endif
 
 #ifndef JUCE_VST_WRAPPER_INVOKE_MAIN
-#define JUCE_VST_WRAPPER_INVOKE_MAIN  effect = module->moduleMain ((Vst2::audioMasterCallback) &audioMaster);
+ #define JUCE_VST_WRAPPER_INVOKE_MAIN  effect = module->moduleMain (&audioMaster);
 #endif
 
 #ifndef JUCE_VST_FALLBACK_HOST_NAME
@@ -220,8 +211,8 @@ namespace
 }
 
 //==============================================================================
-typedef Vst2::AEffect* (VSTCALLBACK *MainCall) (Vst2::audioMasterCallback);
-static pointer_sized_int VSTCALLBACK audioMaster (Vst2::AEffect*, int32, int32, pointer_sized_int, void*, float);
+typedef Vst2::VstEffectInterface* (VSTINTERFACECALL *MainCall) (Vst2::VstHostCallback);
+static pointer_sized_int VSTINTERFACECALL audioMaster (Vst2::VstEffectInterface*, int32, int32, pointer_sized_int, void*, float);
 
 //==============================================================================
 // Change this to disable logging of various VST activities
@@ -689,9 +680,9 @@ struct ModuleHandle    : public ReferenceCountedObject
         module.close();
     }
 
-    void closeEffect (Vst2::AEffect* eff)
+    void closeEffect (Vst2::VstEffectInterface* eff)
     {
-        eff->dispatcher (eff, Vst2::effClose, 0, 0, nullptr, 0);
+        eff->dispatchFunction (eff, Vst2::plugInOpcodeClose, 0, 0, nullptr, 0);
     }
 
    #if JUCE_WINDOWS
@@ -813,9 +804,9 @@ struct ModuleHandle    : public ReferenceCountedObject
         }
     }
 
-    void closeEffect (Vst2::AEffect* eff)
+    void closeEffect (Vst2::VstEffectInterface* eff)
     {
-        eff->dispatcher (eff, Vst2::effClose, 0, 0, nullptr, 0);
+        eff->dispatchFunction (eff, Vst2::plugInOpcodeClose, 0, 0, nullptr, 0);
     }
 
   #endif
@@ -867,7 +858,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
             {
                 const ScopedLock sl (pluginInstance.lock);
 
-                return effect->getParameter (effect, getParameterIndex());
+                return effect->getParameterValueFunction (effect, getParameterIndex());
             }
 
             return 0.0f;
@@ -879,8 +870,8 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
             {
                 const ScopedLock sl (pluginInstance.lock);
 
-                if (effect->getParameter (effect, getParameterIndex()) != newValue)
-                    effect->setParameter (effect, getParameterIndex(), newValue);
+                if (effect->getParameterValueFunction (effect, getParameterIndex()) != newValue)
+                    effect->setParameterValueFunction (effect, getParameterIndex(), newValue);
             }
         }
 
@@ -913,7 +904,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
             if (valueType != nullptr || ! vstValueStrings.isEmpty())
                 return getText (getValue(), 1024);
 
-            return pluginInstance.getTextForOpcode (getParameterIndex(), Vst2::effGetParamDisplay);
+            return pluginInstance.getTextForOpcode (getParameterIndex(), Vst2::plugInOpcodeGetParameterText);
         }
 
         float getDefaultValue() const override
@@ -925,7 +916,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         {
             if (name.isEmpty())
                 return pluginInstance.getTextForOpcode (getParameterIndex(),
-                                                        Vst2::effGetParamName);
+                                                        Vst2::plugInOpcodeGetParameterName);
 
             if (name.length() <= maximumStringLength)
                 return name;
@@ -945,7 +936,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         String getLabel() const override
         {
             return label.isEmpty() ? pluginInstance.getTextForOpcode (getParameterIndex(),
-                                                                      Vst2::effGetParamLabel)
+                                                                      Vst2::plugInOpcodeGetParameterLabel)
                                    : label;
         }
 
@@ -992,7 +983,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         const VSTXMLInfo::ValueType* const valueType;
     };
 
-    VSTPluginInstance (const ModuleHandle::Ptr& mh, const BusesProperties& ioConfig, Vst2::AEffect* effect,
+    VSTPluginInstance (const ModuleHandle::Ptr& mh, const BusesProperties& ioConfig, Vst2::VstEffectInterface* effect,
                        double sampleRateToUse, int blockSizeToUse)
         : AudioPluginInstance (ioConfig),
           vstEffect (effect),
@@ -1015,13 +1006,13 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         AudioProcessorParameterGroup newParameterTree;
 
-        for (int i = 0; i < vstEffect->numParams; ++i)
+        for (int i = 0; i < vstEffect->numParameters; ++i)
         {
             String paramName;
             Array<String> shortParamNames;
             float defaultValue = 0;
             String label;
-            bool isAutomatable = dispatch (Vst2::effCanBeAutomated, i, 0, nullptr, 0) != 0;
+            bool isAutomatable = dispatch (Vst2::plugInOpcodeIsParameterAutomatable, i, 0, nullptr, 0) != 0;
             bool isDiscrete = false;
             int numSteps = AudioProcessor::getDefaultNumParameterSteps();
             bool isBoolSwitch = false;
@@ -1089,13 +1080,13 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
     ~VSTPluginInstance() override
     {
-        if (vstEffect != nullptr && vstEffect->magic == 0x56737450 /* 'VstP' */)
+        if (vstEffect != nullptr && vstEffect->interfaceIdentifier == Vst2::juceVstInterfaceIdentifier)
             callOnMessageThread ([this] { cleanup(); });
     }
 
     void cleanup()
     {
-        if (vstEffect != nullptr && vstEffect->magic == 0x56737450 /* 'VstP' */)
+        if (vstEffect != nullptr && vstEffect->interfaceIdentifier == Vst2::juceVstInterfaceIdentifier)
         {
            #if JUCE_MAC
             if (vstModule->resFileId != 0)
@@ -1120,16 +1111,16 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         if (auto* newEffect = constructEffect (newModule))
         {
-            newEffect->resvd2 = 0;
+            newEffect->hostSpace2 = 0;
 
-            newEffect->dispatcher (newEffect, Vst2::effIdentify, 0, 0, nullptr, 0);
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeIdentify, 0, 0, nullptr, 0);
 
             auto blockSize = jmax (32, initialBlockSize);
 
-            newEffect->dispatcher (newEffect, Vst2::effSetSampleRate, 0, 0, nullptr, static_cast<float> (initialSampleRate));
-            newEffect->dispatcher (newEffect, Vst2::effSetBlockSize,  0, blockSize, nullptr, 0);
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeSetSampleRate, 0, 0, nullptr, static_cast<float> (initialSampleRate));
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeSetBlockSize,  0, blockSize, nullptr, 0);
 
-            newEffect->dispatcher (newEffect, Vst2::effOpen, 0, 0, nullptr, 0);
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeOpen, 0, 0, nullptr, 0);
             BusesProperties ioConfig = queryBusIO (newEffect);
 
             return new VSTPluginInstance (newModule, ioConfig, newEffect, initialSampleRate, blockSize);
@@ -1145,7 +1136,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
         {
             char buffer[512] = { 0 };
-            dispatch (Vst2::effGetEffectName, 0, 0, buffer, 0);
+            dispatch (Vst2::plugInOpcodeGetPlugInName, 0, 0, buffer, 0);
 
             desc.descriptiveName = String::createStringFromData (buffer, (int) sizeof (buffer)).trim();
 
@@ -1162,7 +1153,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
         {
             char buffer[512] = { 0 };
-            dispatch (Vst2::effGetVendorString, 0, 0, buffer, 0);
+            dispatch (Vst2::plugInOpcodeGetManufacturerName, 0, 0, buffer, 0);
             desc.manufacturerName = String::createStringFromData (buffer, (int) sizeof (buffer)).trim();
         }
 
@@ -1176,7 +1167,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         if (vstEffect != nullptr)
         {
-            vstEffect->resvd2 = (pointer_sized_int) (pointer_sized_int) this;
+            vstEffect->hostSpace2 = (pointer_sized_int) (pointer_sized_int) this;
             initialise (initialSampleRate, initialBlockSize);
             return true;
         }
@@ -1202,32 +1193,32 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
         setRateAndBufferSizeDetails (initialSampleRate, initialBlockSize);
 
-        dispatch (Vst2::effIdentify, 0, 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeIdentify, 0, 0, nullptr, 0);
 
         if (getSampleRate() > 0)
-            dispatch (Vst2::effSetSampleRate, 0, 0, nullptr, (float) getSampleRate());
+            dispatch (Vst2::plugInOpcodeSetSampleRate, 0, 0, nullptr, (float) getSampleRate());
 
         if (getBlockSize() > 0)
-            dispatch (Vst2::effSetBlockSize, 0, jmax (32, getBlockSize()), nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetBlockSize, 0, jmax (32, getBlockSize()), nullptr, 0);
 
-        dispatch (Vst2::effOpen, 0, 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeOpen, 0, 0, nullptr, 0);
 
         setRateAndBufferSizeDetails (getSampleRate(), getBlockSize());
 
         if (getNumPrograms() > 1)
             setCurrentProgram (0);
         else
-            dispatch (Vst2::effSetProgram, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetCurrentProgram, 0, 0, nullptr, 0);
 
-        for (int i = vstEffect->numInputs;  --i >= 0;)  dispatch (Vst2::effConnectInput,  i, 1, nullptr, 0);
-        for (int i = vstEffect->numOutputs; --i >= 0;)  dispatch (Vst2::effConnectOutput, i, 1, nullptr, 0);
+        for (int i = vstEffect->numInputChannels;  --i >= 0;)  dispatch (Vst2::plugInOpcodeConnectInput,  i, 1, nullptr, 0);
+        for (int i = vstEffect->numOutputChannels; --i >= 0;)  dispatch (Vst2::plugInOpcodeConnectOutput, i, 1, nullptr, 0);
 
         if (getVstCategory() != Vst2::kPlugCategShell) // (workaround for Waves 5 plugins which crash during this call)
             updateStoredProgramNames();
 
         wantsMidiMessages = pluginCanDo ("receiveVstMidiEvent") > 0 || isSynthPlugin();
 
-        setLatencySamples (vstEffect->initialDelay);
+        setLatencySamples (vstEffect->latency);
     }
 
     void getExtensions (ExtensionsVisitor& visitor) const override
@@ -1252,7 +1243,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         {
             char buffer[512] = { 0 };
 
-            if (dispatch (Vst2::effGetProductString, 0, 0, buffer, 0) != 0)
+            if (dispatch (Vst2::plugInOpcodeGetManufacturerProductName, 0, 0, buffer, 0) != 0)
             {
                 String productName = String::createStringFromData (buffer, (int) sizeof (buffer));
 
@@ -1266,7 +1257,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
     int getUID() const
     {
-        int uid = vstEffect != nullptr ? vstEffect->uniqueID : 0;
+        int uid = vstEffect != nullptr ? vstEffect->plugInIdentifier : 0;
 
         if (uid == 0)
             uid = vstModule->file.hashCode();
@@ -1279,10 +1270,10 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         if (vstEffect == nullptr)
             return 0.0;
 
-        if ((vstEffect->flags & Vst2::effFlagsNoSoundInStop) != 0)
+        if ((vstEffect->flags & 512) != 0)
             return 0.0;
 
-        auto tailSize = dispatch (Vst2::effGetTailSize, 0, 0, nullptr, 0);
+        auto tailSize = dispatch (Vst2::plugInOpcodeGetTailSize, 0, 0, nullptr, 0);
         auto sampleRate = getSampleRate();
 
         // remain backward compatible with old JUCE plug-ins: anything larger
@@ -1302,11 +1293,11 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     bool producesMidi() const override   { return pluginCanDo ("sendVstMidiEvent") > 0; }
     bool supportsMPE() const override    { return pluginCanDo ("MPE") > 0; }
 
-    Vst2::VstPlugCategory getVstCategory() const noexcept     { return (Vst2::VstPlugCategory) dispatch (Vst2::effGetPlugCategory, 0, 0, nullptr, 0); }
+    Vst2::VstPlugInCategory getVstCategory() const noexcept     { return (Vst2::VstPlugInCategory) dispatch (Vst2::plugInOpcodeGetPlugInCategory, 0, 0, nullptr, 0); }
 
-    bool isSynthPlugin() const  { return (vstEffect != nullptr && (vstEffect->flags & Vst2::effFlagsIsSynth) != 0); }
+    bool isSynthPlugin() const  { return (vstEffect != nullptr && (vstEffect->flags & Vst2::vstEffectFlagIsSynth) != 0); }
 
-    int pluginCanDo (const char* text) const  { return (int) dispatch (Vst2::effCanDo, 0, 0, (void*) text,  0); }
+    int pluginCanDo (const char* text) const  { return (int) dispatch (Vst2::plugInOpcodeCanPlugInDo, 0, 0, (void*) text,  0); }
 
     //==============================================================================
     void prepareToPlay (double rate, int samplesPerBlockExpected) override
@@ -1321,17 +1312,17 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
             SpeakerMappings::VstSpeakerConfigurationHolder inArr  (getChannelLayoutOfBus (true,  0));
             SpeakerMappings::VstSpeakerConfigurationHolder outArr (getChannelLayoutOfBus (false, 0));
 
-            dispatch (Vst2::effSetSpeakerArrangement, 0, (pointer_sized_int) &inArr.get(), (void*) &outArr.get(), 0.0f);
+            dispatch (Vst2::plugInOpcodeSetSpeakerConfiguration, 0, (pointer_sized_int) &inArr.get(), (void*) &outArr.get(), 0.0f);
         }
 
-        vstHostTime.tempo = 120.0;
-        vstHostTime.timeSigNumerator = 4;
-        vstHostTime.timeSigDenominator = 4;
+        vstHostTime.tempoBPM = 120.0;
+        vstHostTime.timeSignatureNumerator = 4;
+        vstHostTime.timeSignatureDenominator = 4;
         vstHostTime.sampleRate = rate;
-        vstHostTime.samplePos = 0;
-        vstHostTime.flags = Vst2::kVstNanosValid
-                              | Vst2::kVstAutomationWriting
-                              | Vst2::kVstAutomationReading;
+        vstHostTime.samplePosition = 0;
+        vstHostTime.flags = Vst2::vstTimingInfoFlagNanosecondsValid
+                              | Vst2::vstTimingInfoFlagAutomationWriteModeActive
+                              | Vst2::vstTimingInfoFlagAutomationReadModeActive;
 
         initialise (rate, samplesPerBlockExpected);
 
@@ -1346,18 +1337,18 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
             incomingMidi.clear();
 
-            dispatch (Vst2::effSetSampleRate, 0, 0, nullptr, (float) rate);
-            dispatch (Vst2::effSetBlockSize, 0, jmax (16, samplesPerBlockExpected), nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetSampleRate, 0, 0, nullptr, (float) rate);
+            dispatch (Vst2::plugInOpcodeSetBlockSize, 0, jmax (16, samplesPerBlockExpected), nullptr, 0);
 
             if (supportsDoublePrecisionProcessing())
             {
-                int32 vstPrecision = isUsingDoublePrecision() ? Vst2::kVstProcessPrecision64
-                                                              : Vst2::kVstProcessPrecision32;
+                int32 vstPrecision = isUsingDoublePrecision() ? Vst2::vstProcessingSampleTypeDouble
+                                                              : Vst2::vstProcessingSampleTypeFloat;
 
-                dispatch (Vst2::effSetProcessPrecision, 0, (pointer_sized_int) vstPrecision, nullptr, 0);
+                dispatch (Vst2::plugInOpcodeSetSampleFloatType, 0, (pointer_sized_int) vstPrecision, nullptr, 0);
             }
 
-            auto maxChannels = jmax (1, jmax (vstEffect->numInputs, vstEffect->numOutputs));
+            auto maxChannels = jmax (1, jmax (vstEffect->numInputChannels, vstEffect->numOutputChannels));
 
             tmpBufferFloat .setSize (maxChannels, samplesPerBlockExpected);
             tmpBufferDouble.setSize (maxChannels, samplesPerBlockExpected);
@@ -1365,7 +1356,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
             channelBufferFloat .calloc (static_cast<size_t> (maxChannels));
             channelBufferDouble.calloc (static_cast<size_t> (maxChannels));
 
-            outOfPlaceBuffer.setSize (jmax (1, vstEffect->numOutputs), samplesPerBlockExpected);
+            outOfPlaceBuffer.setSize (jmax (1, vstEffect->numOutputChannels), samplesPerBlockExpected);
 
             if (! isPowerOn)
                 setPower (true);
@@ -1381,9 +1372,9 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
                 }
             }
 
-            dispatch (Vst2::effStartProcess, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeStartProcess, 0, 0, nullptr, 0);
 
-            setLatencySamples (vstEffect->initialDelay);
+            setLatencySamples (vstEffect->latency);
         }
     }
 
@@ -1391,7 +1382,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         if (initialised)
         {
-            dispatch (Vst2::effStopProcess, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeStopProcess, 0, 0, nullptr, 0);
             setPower (false);
         }
 
@@ -1444,8 +1435,8 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     //==============================================================================
     bool supportsDoublePrecisionProcessing() const override
     {
-        return ((vstEffect->flags & Vst2::effFlagsCanReplacing) != 0
-             && (vstEffect->flags & Vst2::effFlagsCanDoubleReplacing) != 0);
+        return ((vstEffect->flags & Vst2::vstEffectFlagInplaceAudio) != 0
+             && (vstEffect->flags & Vst2::vstEffectFlagInplaceDoubleAudio) != 0);
     }
 
     AudioProcessorParameter* getBypassParameter() const override               { return vstSupportsBypass ? bypassParam.get() : nullptr; }
@@ -1463,15 +1454,15 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         if (numInputBuses > 1 || numOutputBuses > 1)
             return (layouts == getBusesLayout());
 
-        return (layouts.getNumChannels (true,  0) <= vstEffect->numInputs
-             && layouts.getNumChannels (false, 0) <= vstEffect->numOutputs);
+        return (layouts.getNumChannels (true,  0) <= vstEffect->numInputChannels
+             && layouts.getNumChannels (false, 0) <= vstEffect->numOutputChannels);
     }
 
     //==============================================================================
    #if JUCE_IOS || JUCE_ANDROID
     bool hasEditor() const override                  { return false; }
    #else
-    bool hasEditor() const override                  { return vstEffect != nullptr && (vstEffect->flags & Vst2::effFlagsHasEditor) != 0; }
+    bool hasEditor() const override                  { return vstEffect != nullptr && (vstEffect->flags & Vst2::vstEffectFlagHasEditor) != 0; }
    #endif
 
     AudioProcessorEditor* createEditor() override;
@@ -1481,9 +1472,9 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         if (isValidChannel (index, true))
         {
-            Vst2::VstPinProperties pinProps;
-            if (dispatch (Vst2::effGetInputProperties, index, 0, &pinProps, 0.0f) != 0)
-                return String (pinProps.label, sizeof (pinProps.label));
+            Vst2::VstPinInfo pinProps;
+            if (dispatch (Vst2::plugInOpcodeGetInputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+                return String (pinProps.text, sizeof (pinProps.text));
         }
 
         return {};
@@ -1494,9 +1485,9 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         if (! isValidChannel (index, true))
             return false;
 
-        Vst2::VstPinProperties pinProps;
-        if (dispatch (Vst2::effGetInputProperties, index, 0, &pinProps, 0.0f) != 0)
-            return (pinProps.flags & Vst2::kVstPinIsStereo) != 0;
+        Vst2::VstPinInfo pinProps;
+        if (dispatch (Vst2::plugInOpcodeGetInputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+            return (pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0;
 
         return true;
     }
@@ -1505,9 +1496,9 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         if (isValidChannel (index, false))
         {
-            Vst2::VstPinProperties pinProps;
-            if (dispatch (Vst2::effGetOutputProperties, index, 0, &pinProps, 0.0f) != 0)
-                return String (pinProps.label, sizeof (pinProps.label));
+            Vst2::VstPinInfo pinProps;
+            if (dispatch (Vst2::plugInOpcodeGetOutputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+                return String (pinProps.text, sizeof (pinProps.text));
         }
 
         return {};
@@ -1518,9 +1509,9 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         if (! isValidChannel (index, false))
             return false;
 
-        Vst2::VstPinProperties pinProps;
-        if (dispatch (Vst2::effGetOutputProperties, index, 0, &pinProps, 0.0f) != 0)
-            return (pinProps.flags & Vst2::kVstPinIsStereo) != 0;
+        Vst2::VstPinInfo pinProps;
+        if (dispatch (Vst2::plugInOpcodeGetOutputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+            return (pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0;
 
         return true;
     }
@@ -1535,12 +1526,12 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     int getNumPrograms() override          { return vstEffect != nullptr ? jmax (0, vstEffect->numPrograms) : 0; }
 
     // NB: some plugs return negative numbers from this function.
-    int getCurrentProgram() override       { return (int) dispatch (Vst2::effGetProgram, 0, 0, nullptr, 0); }
+    int getCurrentProgram() override       { return (int) dispatch (Vst2::plugInOpcodeGetCurrentProgram, 0, 0, nullptr, 0); }
 
     void setCurrentProgram (int newIndex) override
     {
         if (getNumPrograms() > 0 && newIndex != getCurrentProgram())
-            dispatch (Vst2::effSetProgram, 0, jlimit (0, getNumPrograms() - 1, newIndex), nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetCurrentProgram, 0, jlimit (0, getNumPrograms() - 1, newIndex), nullptr, 0);
     }
 
     const String getProgramName (int index) override
@@ -1554,7 +1545,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
             {
                 char nm[264] = { 0 };
 
-                if (dispatch (Vst2::effGetProgramNameIndexed, jlimit (0, getNumPrograms() - 1, index), -1, nm, 0) != 0)
+                if (dispatch (Vst2::plugInOpcodeGetProgramName, jlimit (0, getNumPrograms() - 1, index), -1, nm, 0) != 0)
                     return String::fromUTF8 (nm).trim();
             }
         }
@@ -1567,7 +1558,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         if (index >= 0 && index == getCurrentProgram())
         {
             if (getNumPrograms() > 0 && newName != getCurrentProgramName())
-                dispatch (Vst2::effSetProgramName, 0, 0, (void*) newName.substring (0, 24).toRawUTF8(), 0.0f);
+                dispatch (Vst2::plugInOpcodeSetCurrentProgramName, 0, 0, (void*) newName.substring (0, 24).toRawUTF8(), 0.0f);
         }
         else
         {
@@ -1585,7 +1576,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     //==============================================================================
     void timerCallback() override
     {
-        if (dispatch (Vst2::effIdle, 0, 0, nullptr, 0) == 0)
+        if (dispatch (Vst2::plugInOpcodeIdle, 0, 0, nullptr, 0) == 0)
             stopTimer();
     }
 
@@ -1599,7 +1590,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         switch (opcode)
         {
-            case Vst2::audioMasterAutomate:
+            case Vst2::hostOpcodeParameterChanged:
                 if (auto* param = getParameters()[index])
                     param->sendValueChangedMessageToListeners (opt);
                 else
@@ -1607,23 +1598,23 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
                 break;
 
-            case Vst2::audioMasterProcessEvents:            handleMidiFromPlugin ((const Vst2::VstEvents*) ptr); break;
-            case Vst2::audioMasterGetTime:                  return getVSTTime();
-            case Vst2::audioMasterIdle:                     handleIdle(); break;
-            case Vst2::audioMasterSizeWindow:               setWindowSize (index, (int) value); return 1;
-            case Vst2::audioMasterUpdateDisplay:            triggerAsyncUpdate(); break;
-            case Vst2::audioMasterIOChanged:                setLatencySamples (vstEffect->initialDelay); break;
-            case Vst2::audioMasterNeedIdle:                 startTimer (50); break;
+            case Vst2::hostOpcodePreAudioProcessingEvents:    handleMidiFromPlugin ((const Vst2::VstEventBlock*) ptr); break;
+            case Vst2::hostOpcodeGetTimingInfo:               return getVSTTime();
+            case Vst2::hostOpcodeIdle:                        handleIdle(); break;
+            case Vst2::hostOpcodeWindowSize:                  setWindowSize (index, (int) value); return 1;
+            case Vst2::hostOpcodeUpdateView:                  triggerAsyncUpdate(); break;
+            case Vst2::hostOpcodeIOModified:                  setLatencySamples (vstEffect->latency); break;
+            case Vst2::hostOpcodeNeedsIdle:                   startTimer (50); break;
 
-            case Vst2::audioMasterGetSampleRate:            return (pointer_sized_int) (getSampleRate() > 0 ? getSampleRate() : defaultVSTSampleRateValue);
-            case Vst2::audioMasterGetBlockSize:             return (pointer_sized_int) (getBlockSize() > 0  ? getBlockSize()  : defaultVSTBlockSizeValue);
-            case Vst2::audioMasterWantMidi:                 wantsMidiMessages = true; break;
-            case Vst2::audioMasterGetDirectory:             return getVstDirectory();
+            case Vst2::hostOpcodeGetSampleRate:               return (pointer_sized_int) (getSampleRate() > 0 ? getSampleRate() : defaultVSTSampleRateValue);
+            case Vst2::hostOpcodeGetBlockSize:                return (pointer_sized_int) (getBlockSize() > 0  ? getBlockSize()  : defaultVSTBlockSizeValue);
+            case Vst2::hostOpcodePlugInWantsMidi:             wantsMidiMessages = true; break;
+            case Vst2::hostOpcodeGetDirectory:                return getVstDirectory();
 
-            case Vst2::audioMasterTempoAt:                  return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getTempoAt ((int64) value) : 0);
-            case Vst2::audioMasterGetAutomationState:       return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getAutomationState() : 0);
+            case Vst2::hostOpcodeTempoAt:                     return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getTempoAt ((int64) value) : 0);
+            case Vst2::hostOpcodeGetAutomationState:          return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getAutomationState() : 0);
 
-            case Vst2::audioMasterBeginEdit:
+            case Vst2::hostOpcodeParameterChangeGestureBegin:
                 if (auto* param = getParameters()[index])
                     param->beginChangeGesture();
                 else
@@ -1631,7 +1622,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
                 break;
 
-            case Vst2::audioMasterEndEdit:
+            case Vst2::hostOpcodeParameterChangeGestureEnd:
                 if (auto* param = getParameters()[index])
                     param->endChangeGesture();
                 else
@@ -1639,28 +1630,28 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
                 break;
 
-            case Vst2::audioMasterPinConnected:             return isValidChannel (index, value == 0) ? 0 : 1; // (yes, 0 = true)
-            case Vst2::audioMasterGetCurrentProcessLevel:   return isNonRealtime() ? 4 : 0;
+            case Vst2::hostOpcodePinConnected:                   return isValidChannel (index, value == 0) ? 0 : 1; // (yes, 0 = true)
+            case Vst2::hostOpcodeGetCurrentAudioProcessingLevel: return isNonRealtime() ? 4 : 0;
 
             // none of these are handled (yet)...
-            case Vst2::audioMasterSetTime:
-            case Vst2::audioMasterGetParameterQuantization:
-            case Vst2::audioMasterGetInputLatency:
-            case Vst2::audioMasterGetOutputLatency:
-            case Vst2::audioMasterGetPreviousPlug:
-            case Vst2::audioMasterGetNextPlug:
-            case Vst2::audioMasterWillReplaceOrAccumulate:
-            case Vst2::audioMasterOfflineStart:
-            case Vst2::audioMasterOfflineRead:
-            case Vst2::audioMasterOfflineWrite:
-            case Vst2::audioMasterOfflineGetCurrentPass:
-            case Vst2::audioMasterOfflineGetCurrentMetaPass:
-            case Vst2::audioMasterGetOutputSpeakerArrangement:
-            case Vst2::audioMasterVendorSpecific:
-            case Vst2::audioMasterSetIcon:
-            case Vst2::audioMasterGetLanguage:
-            case Vst2::audioMasterOpenWindow:
-            case Vst2::audioMasterCloseWindow:
+            case Vst2::hostOpcodeSetTime:
+            case Vst2::hostOpcodeGetParameterInterval:
+            case Vst2::hostOpcodeGetInputLatency:
+            case Vst2::hostOpcodeGetOutputLatency:
+            case Vst2::hostOpcodeGetPreviousPlugIn:
+            case Vst2::hostOpcodeGetNextPlugIn:
+            case Vst2::hostOpcodeWillReplace:
+            case Vst2::hostOpcodeOfflineStart:
+            case Vst2::hostOpcodeOfflineReadSource:
+            case Vst2::hostOpcodeOfflineWrite:
+            case Vst2::hostOpcodeOfflineGetCurrentPass:
+            case Vst2::hostOpcodeOfflineGetCurrentMetaPass:
+            case Vst2::hostOpcodeGetOutputSpeakerConfiguration:
+            case Vst2::hostOpcodeManufacturerSpecific:
+            case Vst2::hostOpcodeSetIcon:
+            case Vst2::hostOpcodeGetLanguage:
+            case Vst2::hostOpcodeOpenEditorWindow:
+            case Vst2::hostOpcodeCloseEditorWindow:
                 break;
 
             default:
@@ -1675,19 +1666,19 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         switch (opcode)
         {
-            case Vst2::audioMasterCanDo:                        return handleCanDo ((const char*) ptr);
-            case Vst2::audioMasterVersion:                      return 2400;
-            case Vst2::audioMasterCurrentId:                    return shellUIDToCreate;
-            case Vst2::audioMasterGetNumAutomatableParameters:  return 0;
-            case Vst2::audioMasterGetAutomationState:           return 1;
-            case Vst2::audioMasterGetVendorVersion:             return 0x0101;
+            case Vst2::hostOpcodeCanHostDo:                         return handleCanDo ((const char*) ptr);
+            case Vst2::hostOpcodeVstVersion:                        return 2400;
+            case Vst2::hostOpcodeCurrentId:                         return shellUIDToCreate;
+            case Vst2::hostOpcodeGetNumberOfAutomatableParameters:  return 0;
+            case Vst2::hostOpcodeGetAutomationState:                return 1;
+            case Vst2::hostOpcodeGetManufacturerVersion:            return 0x0101;
 
-            case Vst2::audioMasterGetVendorString:
-            case Vst2::audioMasterGetProductString:             return getHostName ((char*) ptr);
+            case Vst2::hostOpcodeGetManufacturerName:
+            case Vst2::hostOpcodeGetProductName:                    return getHostName ((char*) ptr);
 
-            case Vst2::audioMasterGetSampleRate:                return (pointer_sized_int) defaultVSTSampleRateValue;
-            case Vst2::audioMasterGetBlockSize:                 return (pointer_sized_int) defaultVSTBlockSizeValue;
-            case Vst2::audioMasterSetOutputSampleRate:          return 0;
+            case Vst2::hostOpcodeGetSampleRate:                     return (pointer_sized_int) defaultVSTSampleRateValue;
+            case Vst2::hostOpcodeGetBlockSize:                      return (pointer_sized_int) defaultVSTBlockSizeValue;
+            case Vst2::hostOpcodeSetOutputSampleRate:               return 0;
 
             default:
                 DBG ("*** Unhandled VST Callback: " + String ((int) opcode));
@@ -1716,7 +1707,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
                     UseResFile (vstModule->resFileId);
                #endif
 
-                result = vstEffect->dispatcher (vstEffect, opcode, index, value, ptr, opt);
+                result = vstEffect->dispatchFunction (vstEffect, opcode, index, value, ptr, opt);
 
                #if JUCE_MAC
                 auto newResFile = CurResFile();
@@ -1922,14 +1913,14 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
         return true;
     }
 
-    bool usesChunks() const noexcept        { return vstEffect != nullptr && (vstEffect->flags & Vst2::effFlagsProgramChunks) != 0; }
+    bool usesChunks() const noexcept        { return vstEffect != nullptr && (vstEffect->flags & Vst2::vstEffectFlagDataInChunks) != 0; }
 
     bool getChunkData (MemoryBlock& mb, bool isPreset, int maxSizeMB) const
     {
         if (usesChunks())
         {
             void* data = nullptr;
-            auto bytes = (size_t) dispatch (Vst2::effGetChunk, isPreset ? 1 : 0, 0, &data, 0.0f);
+            auto bytes = (size_t) dispatch (Vst2::plugInOpcodeGetData, isPreset ? 1 : 0, 0, &data, 0.0f);
 
             if (data != nullptr && bytes <= (size_t) maxSizeMB * 1024 * 1024)
             {
@@ -1947,7 +1938,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
     {
         if (size > 0 && usesChunks())
         {
-            dispatch (Vst2::effSetChunk, isPreset ? 1 : 0, size, (void*) data, 0.0f);
+            dispatch (Vst2::plugInOpcodeSetData, isPreset ? 1 : 0, size, (void*) data, 0.0f);
 
             if (! isPreset)
                 updateStoredProgramNames();
@@ -1960,7 +1951,7 @@ struct VSTPluginInstance final   : public AudioPluginInstance,
 
     bool updateSizeFromEditor (int w, int h);
 
-    Vst2::AEffect* vstEffect;
+    Vst2::VstEffectInterface* vstEffect;
     ModuleHandle::Ptr vstModule;
 
     std::unique_ptr<VSTPluginFormat::ExtraFunctions> extraFunctions;
@@ -1982,7 +1973,7 @@ private:
             currentValue = (newValue != 0.0f);
 
             if (parent.vstSupportsBypass)
-                parent.dispatch (Vst2::effSetBypass, 0, currentValue ? 1 : 0, nullptr, 0.0f);
+                parent.dispatch (Vst2::plugInOpcodeSetBypass, 0, currentValue ? 1 : 0, nullptr, 0.0f);
         }
 
         float getValueForText (const String& text) const override
@@ -2030,7 +2021,7 @@ private:
     CriticalSection midiInLock;
     MidiBuffer incomingMidi;
     VSTMidiEventList midiEventsToSend;
-    Vst2::VstTimeInfo vstHostTime;
+    Vst2::VstTimingInformation vstHostTime;
 
     AudioBuffer<float> tmpBufferFloat;
     HeapBlock<float*> channelBufferFloat;
@@ -2067,7 +2058,7 @@ private:
         if (auto* app = JUCEApplicationBase::getInstance())
             hostName = app->getApplicationName();
 
-        hostName.copyToUTF8 (name, (size_t) jmin (Vst2::kVstMaxVendorStrLen, Vst2::kVstMaxProductStrLen) - 1);
+        hostName.copyToUTF8 (name, (size_t) jmin (Vst2::vstMaxManufacturerStringLength, Vst2::vstMaxPlugInNameStringLength) - 1);
         return 1;
     }
 
@@ -2088,7 +2079,7 @@ private:
 
            #if JUCE_MAC
             if (getActiveEditor() != nullptr)
-                dispatch (Vst2::effEditIdle, 0, 0, nullptr, 0);
+                dispatch (Vst2::plugInOpcodeEditorIdle, 0, 0, nullptr, 0);
            #endif
 
             Timer::callPendingTimersSynchronously();
@@ -2110,9 +2101,9 @@ private:
     }
 
     //==============================================================================
-    static Vst2::AEffect* constructEffect (const ModuleHandle::Ptr& module)
+    static Vst2::VstEffectInterface* constructEffect (const ModuleHandle::Ptr& module)
     {
-        Vst2::AEffect* effect = nullptr;
+        Vst2::VstEffectInterface* effect = nullptr;
         try
         {
             const IdleCallRecursionPreventer icrp;
@@ -2129,10 +2120,10 @@ private:
                 JUCE_VST_WRAPPER_INVOKE_MAIN
             }
 
-            if (effect != nullptr && effect->magic == 0x56737450 /* 'VstP' */)
+            if (effect != nullptr && effect->interfaceIdentifier == Vst2::juceVstInterfaceIdentifier)
             {
-                jassert (effect->resvd2 == 0);
-                jassert (effect->object != nullptr);
+                jassert (effect->hostSpace2 == 0);
+                jassert (effect->effectPointer != nullptr);
 
                 _fpreset(); // some dodgy plugs mess around with this
             }
@@ -2147,11 +2138,11 @@ private:
         return effect;
     }
 
-    static BusesProperties queryBusIO (Vst2::AEffect* effect)
+    static BusesProperties queryBusIO (Vst2::VstEffectInterface* effect)
     {
         BusesProperties returnValue;
 
-        if (effect->numInputs == 0 && effect->numOutputs == 0)
+        if (effect->numInputChannels == 0 && effect->numOutputChannels == 0)
             return returnValue;
 
         // Workaround for old broken JUCE plug-ins which would return an invalid
@@ -2162,10 +2153,10 @@ private:
         // plug-in is reporting.
         if (! pluginHasDefaultChannelLayouts (effect))
         {
-            SpeakerMappings::VstSpeakerConfigurationHolder canonicalIn  (AudioChannelSet::canonicalChannelSet (effect->numInputs));
-            SpeakerMappings::VstSpeakerConfigurationHolder canonicalOut (AudioChannelSet::canonicalChannelSet (effect->numOutputs));
+            SpeakerMappings::VstSpeakerConfigurationHolder canonicalIn  (AudioChannelSet::canonicalChannelSet (effect->numInputChannels));
+            SpeakerMappings::VstSpeakerConfigurationHolder canonicalOut (AudioChannelSet::canonicalChannelSet (effect->numOutputChannels));
 
-            effect->dispatcher (effect, Vst2::effSetSpeakerArrangement, 0,
+            effect->dispatchFunction (effect, Vst2::plugInOpcodeSetSpeakerConfiguration, 0,
                                       (pointer_sized_int) &canonicalIn.get(), (void*) &canonicalOut.get(), 0.0f);
         }
 
@@ -2174,35 +2165,35 @@ private:
         for (int dir = 0; dir < 2; ++dir)
         {
             const bool isInput = (dir == 0);
-            const int opcode = (isInput ? Vst2::effGetInputProperties : Vst2::effGetOutputProperties);
-            const int maxChannels = (isInput ? effect->numInputs : effect->numOutputs);
+            const int opcode = (isInput ? Vst2::plugInOpcodeGetInputPinProperties : Vst2::plugInOpcodeGetOutputPinProperties);
+            const int maxChannels = (isInput ? effect->numInputChannels : effect->numOutputChannels);
             const auto* arr = (isInput ? arrangement.in : arrangement.out);
             bool busAdded = false;
 
-            Vst2::VstPinProperties pinProps;
+            Vst2::VstPinInfo pinProps;
             AudioChannelSet layout;
 
             for (int ch = 0; ch < maxChannels; ch += layout.size())
             {
-                if (effect->dispatcher (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
+                if (effect->dispatchFunction (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
                     break;
 
-                if ((pinProps.flags & Vst2::kVstPinUseSpeaker) != 0)
+                if ((pinProps.flags & Vst2::vstPinInfoFlagValid) != 0)
                 {
-                    layout = SpeakerMappings::vstArrangementTypeToChannelSet (pinProps.arrangementType, 0);
+                    layout = SpeakerMappings::vstArrangementTypeToChannelSet (pinProps.configurationType, 0);
 
                     if (layout.isDisabled())
                         break;
                 }
                 else if (arr == nullptr)
                 {
-                    layout = ((pinProps.flags & Vst2::kVstPinIsStereo) != 0 ? AudioChannelSet::stereo() : AudioChannelSet::mono());
+                    layout = ((pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0 ? AudioChannelSet::stereo() : AudioChannelSet::mono());
                 }
                 else
                     break;
 
                 busAdded = true;
-                returnValue.addBus (isInput, pinProps.label, layout, true);
+                returnValue.addBus (isInput, pinProps.text, layout, true);
             }
 
             // no buses?
@@ -2210,8 +2201,8 @@ private:
             {
                 String busName = (isInput ? "Input" : "Output");
 
-                if (effect->dispatcher (effect, opcode, 0, 0, &pinProps, 0.0f) != 0)
-                    busName = pinProps.label;
+                if (effect->dispatchFunction (effect, opcode, 0, 0, &pinProps, 0.0f) != 0)
+                    busName = pinProps.text;
 
                 if (arr != nullptr)
                     layout = SpeakerMappings::vstArrangementTypeToChannelSet (*arr);
@@ -2225,7 +2216,7 @@ private:
         return returnValue;
     }
 
-    static bool pluginHasDefaultChannelLayouts (Vst2::AEffect* effect)
+    static bool pluginHasDefaultChannelLayouts (Vst2::VstEffectInterface* effect)
     {
         if (getSpeakerArrangementWrapper (effect).isValid())
             return true;
@@ -2233,22 +2224,22 @@ private:
         for (int dir = 0; dir < 2; ++dir)
         {
             const bool isInput = (dir == 0);
-            const int opcode = (isInput ? Vst2::effGetInputProperties : Vst2::effGetOutputProperties);
-            const int maxChannels = (isInput ? effect->numInputs : effect->numOutputs);
+            const int opcode = (isInput ? Vst2::plugInOpcodeGetInputPinProperties : Vst2::plugInOpcodeGetOutputPinProperties);
+            const int maxChannels = (isInput ? effect->numInputChannels : effect->numOutputChannels);
 
             int channels = 1;
 
             for (int ch = 0; ch < maxChannels; ch += channels)
             {
-                Vst2::VstPinProperties pinProps;
+                Vst2::VstPinInfo pinProps;
 
-                if (effect->dispatcher (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
+                if (effect->dispatchFunction (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
                     return false;
 
-                if ((pinProps.flags & Vst2::kVstPinUseSpeaker) != 0)
+                if ((pinProps.flags & Vst2::vstPinInfoFlagValid) != 0)
                     return true;
 
-                channels = (pinProps.flags & Vst2::kVstPinIsStereo) != 0 ? 2 : 1;
+                channels = (pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0 ? 2 : 1;
             }
         }
 
@@ -2257,28 +2248,28 @@ private:
 
     struct SpeakerArrangements
     {
-        const Vst2::VstSpeakerArrangement* in;
-        const Vst2::VstSpeakerArrangement* out;
+        const Vst2::VstSpeakerConfiguration* in;
+        const Vst2::VstSpeakerConfiguration* out;
 
         bool isValid() const noexcept { return in != nullptr && out != nullptr; }
     };
 
-    static SpeakerArrangements getSpeakerArrangementWrapper (Vst2::AEffect* effect)
+    static SpeakerArrangements getSpeakerArrangementWrapper (Vst2::VstEffectInterface* effect)
     {
         // Workaround: unfortunately old JUCE VST-2 plug-ins had a bug and would crash if
         // you try to get the speaker arrangement when there are no input channels present.
         // Hopefully, one day (when there are no more old JUCE plug-ins around), we can
         // comment out the next two lines.
-        if (effect->numInputs == 0)
+        if (effect->numInputChannels == 0)
             return { nullptr, nullptr };
 
         SpeakerArrangements result { nullptr, nullptr };
-        const auto dispatchResult = effect->dispatcher (effect,
-                                                        Vst2::effGetSpeakerArrangement,
-                                                        0,
-                                                        reinterpret_cast<pointer_sized_int> (&result.in),
-                                                        &result.out,
-                                                        0.0f);
+        const auto dispatchResult = effect->dispatchFunction (effect,
+                                                              Vst2::plugInOpcodeGetSpeakerArrangement,
+                                                              0,
+                                                              reinterpret_cast<pointer_sized_int> (&result.in),
+                                                              &result.out,
+                                                              0.0f);
 
         if (dispatchResult != 0)
             return result;
@@ -2328,77 +2319,77 @@ private:
                 if (const auto position = currentPlayHead->getPosition())
                 {
                     if (const auto samplePos = position->getTimeInSamples())
-                        vstHostTime.samplePos = (double) *samplePos;
+                        vstHostTime.samplePosition = (double) *samplePos;
                     else
                         jassertfalse; // VST hosts *must* call setTimeInSamples on the audio playhead
 
                     if (auto sig = position->getTimeSignature())
                     {
-                        vstHostTime.flags |= Vst2::kVstTimeSigValid;
-                        vstHostTime.timeSigNumerator   = sig->numerator;
-                        vstHostTime.timeSigDenominator = sig->denominator;
+                        vstHostTime.flags |= Vst2::vstTimingInfoFlagTimeSignatureValid;
+                        vstHostTime.timeSignatureNumerator   = sig->numerator;
+                        vstHostTime.timeSignatureDenominator = sig->denominator;
                     }
                     else
                     {
-                        vstHostTime.flags &= ~Vst2::kVstTimeSigValid;
+                        vstHostTime.flags &= ~Vst2::vstTimingInfoFlagTimeSignatureValid;
                     }
 
-                    setFromOptional (vstHostTime.ppqPos,      position->getPpqPosition(),               Vst2::kVstPpqPosValid);
-                    setFromOptional (vstHostTime.barStartPos, position->getPpqPositionOfLastBarStart(), Vst2::kVstBarsValid);
-                    setFromOptional (vstHostTime.nanoSeconds, position->getHostTimeNs(),                Vst2::kVstNanosValid);
-                    setFromOptional (vstHostTime.tempo,       position->getBpm(),                       Vst2::kVstTempoValid);
+                    setFromOptional (vstHostTime.musicalPosition,       position->getPpqPosition(),               Vst2::vstTimingInfoFlagMusicalPositionValid);
+                    setFromOptional (vstHostTime.lastBarPosition,       position->getPpqPositionOfLastBarStart(), Vst2::vstTimingInfoFlagLastBarPositionValid);
+                    setFromOptional (vstHostTime.systemTimeNanoseconds, position->getHostTimeNs(),                Vst2::vstTimingInfoFlagNanosecondsValid);
+                    setFromOptional (vstHostTime.tempoBPM,              position->getBpm(),                       Vst2::vstTimingInfoFlagTempoValid);
 
                     int32 newTransportFlags = 0;
-                    if (position->getIsPlaying())     newTransportFlags |= Vst2::kVstTransportPlaying;
-                    if (position->getIsRecording())   newTransportFlags |= Vst2::kVstTransportRecording;
+                    if (position->getIsPlaying())     newTransportFlags |= Vst2::vstTimingInfoFlagCurrentlyPlaying;
+                    if (position->getIsRecording())   newTransportFlags |= Vst2::vstTimingInfoFlagCurrentlyRecording;
 
-                    if (newTransportFlags != (vstHostTime.flags & (Vst2::kVstTransportPlaying
-                                                                   | Vst2::kVstTransportRecording)))
-                        vstHostTime.flags = (vstHostTime.flags & ~(Vst2::kVstTransportPlaying | Vst2::kVstTransportRecording)) | newTransportFlags | Vst2::kVstTransportChanged;
+                    if (newTransportFlags != (vstHostTime.flags & (Vst2::vstTimingInfoFlagCurrentlyPlaying
+                                                                   | Vst2::vstTimingInfoFlagCurrentlyRecording)))
+                        vstHostTime.flags = (vstHostTime.flags & ~(Vst2::vstTimingInfoFlagCurrentlyPlaying | Vst2::vstTimingInfoFlagCurrentlyRecording)) | newTransportFlags | Vst2::vstTimingInfoFlagTransportChanged;
                     else
-                        vstHostTime.flags &= ~Vst2::kVstTransportChanged;
+                        vstHostTime.flags &= ~Vst2::vstTimingInfoFlagTransportChanged;
 
-                    const auto optionalFrameRate = [fr = position->getFrameRate()]() -> Optional<Vst2::VstInt32>
+                    const auto optionalFrameRate = [fr = position->getFrameRate()]() -> Optional<int32>
                     {
                         if (! fr.hasValue())
                             return {};
 
                         switch (fr->getBaseRate())
                         {
-                            case 24:        return fr->isPullDown() ? Vst2::kVstSmpte239fps : Vst2::kVstSmpte24fps;
-                            case 25:        return fr->isPullDown() ? Vst2::kVstSmpte249fps : Vst2::kVstSmpte25fps;
-                            case 30:        return fr->isPullDown() ? (fr->isDrop() ? Vst2::kVstSmpte2997dfps : Vst2::kVstSmpte2997fps)
-                                                                    : (fr->isDrop() ? Vst2::kVstSmpte30dfps   : Vst2::kVstSmpte30fps);
-                            case 60:        return fr->isPullDown() ? Vst2::kVstSmpte599fps : Vst2::kVstSmpte60fps;
+                            case 24:        return fr->isPullDown() ? Vst2::vstSmpteRateFps239 : Vst2::vstSmpteRateFps24;
+                            case 25:        return fr->isPullDown() ? Vst2::vstSmpteRateFps249 : Vst2::vstSmpteRateFps25;
+                            case 30:        return fr->isPullDown() ? (fr->isDrop() ? Vst2::vstSmpteRateFps2997drop : Vst2::vstSmpteRateFps2997)
+                                                                    : (fr->isDrop() ? Vst2::vstSmpteRateFps30drop   : Vst2::vstSmpteRateFps30);
+                            case 60:        return fr->isPullDown() ? Vst2::vstSmpteRateFps599 : Vst2::vstSmpteRateFps60;
                         }
 
                         return {};
                     }();
 
-                    vstHostTime.flags |= optionalFrameRate ? Vst2::kVstSmpteValid : 0;
-                    vstHostTime.smpteFrameRate = optionalFrameRate.orFallback (Vst2::VstSmpteFrameRate{});
+                    vstHostTime.flags |= optionalFrameRate ? Vst2::vstTimingInfoFlagSmpteValid : 0;
+                    vstHostTime.smpteRate = optionalFrameRate.orFallback (0);
                     const auto effectiveRate = position->getFrameRate().hasValue() ? position->getFrameRate()->getEffectiveRate() : 0.0;
                     vstHostTime.smpteOffset = (int32) (position->getTimeInSeconds().orFallback (0.0) * 80.0 * effectiveRate + 0.5);
 
                     if (const auto loop = position->getLoopPoints())
                     {
-                        vstHostTime.flags |= Vst2::kVstCyclePosValid;
-                        vstHostTime.cycleStartPos = loop->ppqStart;
-                        vstHostTime.cycleEndPos   = loop->ppqEnd;
+                        vstHostTime.flags |= Vst2::vstTimingInfoFlagLoopPositionValid;
+                        vstHostTime.loopStartPosition = loop->ppqStart;
+                        vstHostTime.loopEndPosition   = loop->ppqEnd;
                     }
                     else
                     {
-                        vstHostTime.flags &= ~Vst2::kVstCyclePosValid;
+                        vstHostTime.flags &= ~Vst2::vstTimingInfoFlagLoopPositionValid;
                     }
 
                     if (position->getIsLooping())
-                        vstHostTime.flags |= Vst2::kVstTransportCycleActive;
+                        vstHostTime.flags |= Vst2::vstTimingInfoFlagLoopActive;
                     else
-                        vstHostTime.flags &= ~Vst2::kVstTransportCycleActive;
+                        vstHostTime.flags &= ~Vst2::vstTimingInfoFlagLoopActive;
                 }
             }
 
-            vstHostTime.nanoSeconds = getVSTHostTimeNanoseconds();
+            vstHostTime.systemTimeNanoseconds = getVSTHostTimeNanoseconds();
 
             if (wantsMidiMessages)
             {
@@ -2409,13 +2400,13 @@ private:
                     midiEventsToSend.addEvent (metadata.data, metadata.numBytes,
                                                jlimit (0, numSamples - 1, metadata.samplePosition));
 
-                vstEffect->dispatcher (vstEffect, Vst2::effProcessEvents, 0, 0, midiEventsToSend.events, 0);
+                vstEffect->dispatchFunction (vstEffect, Vst2::plugInOpcodePreAudioProcessingEvents, 0, 0, midiEventsToSend.events, 0);
             }
 
             _clearfp();
 
             // always ensure that the buffer is at least as large as the maximum number of channels
-            auto maxChannels = jmax (vstEffect->numInputs, vstEffect->numOutputs);
+            auto maxChannels = jmax (vstEffect->numInputChannels, vstEffect->numOutputChannels);
             auto channels = channelBuffer.get();
 
             if (numChannels < maxChannels)
@@ -2454,28 +2445,28 @@ private:
     //==============================================================================
     inline void invokeProcessFunction (AudioBuffer<float>& buffer, int32 sampleFrames)
     {
-        if ((vstEffect->flags & Vst2::effFlagsCanReplacing) != 0)
+        if ((vstEffect->flags & Vst2::vstEffectFlagInplaceAudio) != 0)
         {
-            vstEffect->processReplacing (vstEffect, buffer.getArrayOfWritePointers(),
-                                                    buffer.getArrayOfWritePointers(), sampleFrames);
+            vstEffect->processAudioInplaceFunction (vstEffect, buffer.getArrayOfWritePointers(),
+                                                               buffer.getArrayOfWritePointers(), sampleFrames);
         }
         else
         {
-            outOfPlaceBuffer.setSize (vstEffect->numOutputs, sampleFrames);
+            outOfPlaceBuffer.setSize (vstEffect->numOutputChannels, sampleFrames);
             outOfPlaceBuffer.clear();
 
-            vstEffect->process (vstEffect, buffer.getArrayOfWritePointers(),
-                                           outOfPlaceBuffer.getArrayOfWritePointers(), sampleFrames);
+            vstEffect->processAudioFunction (vstEffect, buffer.getArrayOfWritePointers(),
+                                                        outOfPlaceBuffer.getArrayOfWritePointers(), sampleFrames);
 
-            for (int i = vstEffect->numOutputs; --i >= 0;)
+            for (int i = vstEffect->numOutputChannels; --i >= 0;)
                 buffer.copyFrom (i, 0, outOfPlaceBuffer.getReadPointer (i), sampleFrames);
         }
     }
 
     inline void invokeProcessFunction (AudioBuffer<double>& buffer, int32 sampleFrames)
     {
-        vstEffect->processDoubleReplacing (vstEffect, buffer.getArrayOfWritePointers(),
-                                                      buffer.getArrayOfWritePointers(), sampleFrames);
+        vstEffect->processDoubleAudioInplaceFunction (vstEffect, buffer.getArrayOfWritePointers(),
+                                                                 buffer.getArrayOfWritePointers(), sampleFrames);
     }
 
     //==============================================================================
@@ -2501,7 +2492,7 @@ private:
         if (vstEffect == nullptr)
             return {};
 
-        jassert (index >= 0 && index < vstEffect->numParams);
+        jassert (index >= 0 && index < vstEffect->numParameters);
         char nm[256] = { 0 };
         dispatch (opcode, index, 0, nm, 0);
         return String::createStringFromData (nm, (int) sizeof (nm)).trim();
@@ -2515,7 +2506,7 @@ private:
         {
             {
                 char nm[256] = { 0 };
-                dispatch (Vst2::effGetProgramName, 0, 0, nm, 0);
+                dispatch (Vst2::plugInOpcodeGetCurrentProgramName, 0, 0, nm, 0);
                 progName = String::createStringFromData (nm, (int) sizeof (nm)).trim();
             }
 
@@ -2559,7 +2550,7 @@ private:
             char nm[256] = { 0 };
 
             // only do this if the plugin can't use indexed names.
-            if (dispatch (Vst2::effGetProgramNameIndexed, 0, -1, nm, 0) == 0)
+            if (dispatch (Vst2::plugInOpcodeGetProgramName, 0, -1, nm, 0) == 0)
             {
                 auto oldProgram = getCurrentProgram();
                 MemoryBlock oldSettings;
@@ -2577,7 +2568,7 @@ private:
         }
     }
 
-    void handleMidiFromPlugin (const Vst2::VstEvents* events)
+    void handleMidiFromPlugin (const Vst2::VstEventBlock* events)
     {
         if (events != nullptr)
         {
@@ -2624,11 +2615,11 @@ private:
     }
 
     //==============================================================================
-    int getVersionNumber() const noexcept   { return vstEffect != nullptr ? vstEffect->version : 0; }
+    int getVersionNumber() const noexcept   { return vstEffect != nullptr ? vstEffect->plugInVersion : 0; }
 
     String getVersion() const
     {
-        auto v = (unsigned int) dispatch (Vst2::effGetVendorVersion, 0, 0, nullptr, 0);
+        auto v = (unsigned int) dispatch (Vst2::plugInOpcodeGetManufacturerVersion, 0, 0, nullptr, 0);
 
         String s;
 
@@ -2696,7 +2687,6 @@ private:
             case Vst2::kPlugCategOfflineProcess:  return "Offline Process";
             case Vst2::kPlugCategShell:           return "Shell";
             case Vst2::kPlugCategUnknown:         return "Unknown";
-            case Vst2::kPlugCategMaxCount:
             default:                              break;
         }
 
@@ -2705,7 +2695,7 @@ private:
 
     void setPower (const bool on)
     {
-        dispatch (Vst2::effMainsChanged, 0, on ? 1 : 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeResumeSuspend, 0, on ? 1 : 0, nullptr, 0);
         isPowerOn = on;
     }
 
@@ -2761,11 +2751,11 @@ public:
 
         activeVSTWindows.add (this);
 
-        Vst2::ERect* rect = nullptr;
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
+        Vst2::VstEditorBounds* rect = nullptr;
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
 
         if (rect != nullptr)
-            updateSizeFromEditor (rect->right - rect->left, rect->bottom - rect->top);
+            updateSizeFromEditor (rect->rightmost - rect->leftmost, rect->lower - rect->upper);
         else
             updateSizeFromEditor (1, 1);
 
@@ -2936,7 +2926,7 @@ public:
     void setContentScaleFactor()
     {
         if (pluginRespondsToDPIChanges)
-            dispatch (Vst2::effVendorSpecific,
+            dispatch (Vst2::plugInOpcodeManufacturerSpecific,
                       (int) ByteOrder::bigEndianInt ("PreS"),
                       (int) ByteOrder::bigEndianInt ("AeCs"),
                       nullptr, getEffectiveScale());
@@ -2984,7 +2974,7 @@ public:
                 // DPI awareness is set correctly inside this call.
                 ScopedThreadDPIAwarenessSetter scope (getPluginHWND());
                #endif
-                plugin.dispatch (Vst2::effEditIdle, 0, 0, nullptr, 0);
+                plugin.dispatch (Vst2::plugInOpcodeEditorIdle, 0, 0, nullptr, 0);
 
                 reentrantGuard = false;
             }
@@ -3017,7 +3007,7 @@ public:
         activeVSTWindows.add (this);
 
        #if JUCE_MAC
-        dispatch (Vst2::effEditTop, 0, 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeeffEditorTop, 0, 0, nullptr, 0);
        #endif
     }
 
@@ -3047,24 +3037,24 @@ private:
 
         isOpen = true;
 
-        Vst2::ERect* rect = nullptr;
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
-        dispatch (Vst2::effEditOpen, 0, 0, parentWindow, 0);
+        Vst2::VstEditorBounds* rect = nullptr;
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
+        dispatch (Vst2::plugInOpcodeOpenEditor, 0, 0, parentWindow, 0);
 
         // do this before and after like in the steinberg example
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
-        dispatch (Vst2::effGetProgram, 0, 0, nullptr, 0); // also in steinberg code
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
+        dispatch (Vst2::plugInOpcodeGetCurrentProgram, 0, 0, nullptr, 0); // also in steinberg code
 
         // Install keyboard hooks
-        pluginWantsKeys = (dispatch (Vst2::effKeysRequired, 0, 0, nullptr, 0) == 0);
+        pluginWantsKeys = (dispatch (Vst2::plugInOpcodeKeyboardFocusRequired, 0, 0, nullptr, 0) == 0);
 
         // double-check it's not too tiny
         int w = 250, h = 150;
 
         if (rect != nullptr)
         {
-            w = rect->right - rect->left;
-            h = rect->bottom - rect->top;
+            w = rect->rightmost - rect->leftmost;
+            h = rect->lower - rect->upper;
 
             if (w == 0 || h == 0)
             {
@@ -3094,20 +3084,20 @@ private:
 
         setContentScaleFactor();
 
-        Vst2::ERect* rect = nullptr;
+        Vst2::VstEditorBounds* rect = nullptr;
 
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
 
        #if JUCE_WINDOWS
         auto* handle = embeddedComponent.getHWND();
        #else
         auto* handle = getWindowHandle();
        #endif
-        dispatch (Vst2::effEditOpen, 0, 0, handle, 0);
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);  // do this before and after like in the steinberg example
-        dispatch (Vst2::effGetProgram, 0, 0, nullptr, 0); // also in steinberg code
+        dispatch (Vst2::plugInOpcodeOpenEditor, 0, 0, handle, 0);
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);  // do this before and after like in the steinberg example
+        dispatch (Vst2::plugInOpcodeGetCurrentProgram, 0, 0, nullptr, 0); // also in steinberg code
 
-        pluginWantsKeys = (dispatch (Vst2::effKeysRequired, 0, 0, nullptr, 0) == 0);
+        pluginWantsKeys = (dispatch (Vst2::plugInOpcodeKeyboardFocusRequired, 0, 0, nullptr, 0) == 0);
 
        #if JUCE_WINDOWS
         originalWndProc = 0;
@@ -3142,8 +3132,8 @@ private:
 
         if (rect != nullptr)
         {
-            auto rw = rect->right - rect->left;
-            auto rh = rect->bottom - rect->top;
+            auto rw = rect->rightmost - rect->leftmost;
+            auto rh = rect->lower - rect->upper;
 
             if ((rw > 50 && rh > 50 && rw < 2000 && rh < 2000 && (! isWithin (w, rw, 2) || ! isWithin (h, rh, 2)))
                 || ((w == 0 && rw > 0) || (h == 0 && rh > 0)))
@@ -3176,8 +3166,8 @@ private:
 
         if (rect != nullptr)
         {
-            w = rect->right - rect->left;
-            h = rect->bottom - rect->top;
+            w = rect->rightmost - rect->leftmost;
+            h = rect->lower - rect->upper;
 
             if (w == 0 || h == 0)
             {
@@ -3216,7 +3206,7 @@ private:
 
             JUCE_VST_LOG ("Closing VST UI: " + plugin.getName());
             isOpen = false;
-            dispatch (Vst2::effEditClose, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeCloseEditor, 0, 0, nullptr, 0);
             stopTimer();
 
            #if JUCE_WINDOWS
@@ -3253,11 +3243,11 @@ private:
 
     void resizeToFit()
     {
-        Vst2::ERect* rect = nullptr;
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
+        Vst2::VstEditorBounds* rect = nullptr;
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
 
-        auto w = rect->right - rect->left;
-        auto h = rect->bottom - rect->top;
+        auto w = rect->rightmost - rect->leftmost;
+        auto h = rect->lower - rect->upper;
 
         if (! isWindowSizeCorrectForPlugin (w, h))
         {
@@ -3426,10 +3416,10 @@ bool VSTPluginInstance::updateSizeFromEditor (int w, int h)
 
 //==============================================================================
 // entry point for all callbacks from the plugin
-static pointer_sized_int VSTCALLBACK audioMaster (Vst2::AEffect* effect, int32 opcode, int32 index, pointer_sized_int value, void* ptr, float opt)
+static pointer_sized_int VSTINTERFACECALL audioMaster (Vst2::VstEffectInterface* effect, int32 opcode, int32 index, pointer_sized_int value, void* ptr, float opt)
 {
     if (effect != nullptr)
-        if (auto* instance = (VSTPluginInstance*) (effect->resvd2))
+        if (auto* instance = (VSTPluginInstance*) (effect->hostSpace2))
             return instance->handleCallback (opcode, index, value, ptr, opt);
 
     return VSTPluginInstance::handleGeneralCallback (opcode, index, value, ptr, opt);
@@ -3480,7 +3470,7 @@ void VSTPluginFormat::findAllTypesForFile (OwnedArray<PluginDescription>& result
         // Normal plugin...
         results.add (new PluginDescription (desc));
 
-        instance->dispatch (Vst2::effOpen, 0, 0, nullptr, 0);
+        instance->dispatch (Vst2::plugInOpcodeOpen, 0, 0, nullptr, 0);
     }
     else
     {
@@ -3488,7 +3478,7 @@ void VSTPluginFormat::findAllTypesForFile (OwnedArray<PluginDescription>& result
         for (;;)
         {
             char shellEffectName [256] = { 0 };
-            auto uid = (int) instance->dispatch (Vst2::effShellGetNextPlugin, 0, 0, shellEffectName, 0);
+            auto uid = (int) instance->dispatch (Vst2::plugInOpcodeNextPlugInUniqueID, 0, 0, shellEffectName, 0);
 
             if (uid == 0)
                 break;
@@ -3707,8 +3697,8 @@ void VSTPluginFormat::setExtraFunctions (AudioPluginInstance* plugin, ExtraFunct
 
 AudioPluginInstance* VSTPluginFormat::getPluginInstanceFromVstEffectInterface (void* aEffect)
 {
-    if (auto* vstAEffect = reinterpret_cast<Vst2::AEffect*> (aEffect))
-        if (auto* instanceVST = reinterpret_cast<VSTPluginInstance*> (vstAEffect->resvd2))
+    if (auto* vstAEffect = reinterpret_cast<Vst2::VstEffectInterface*> (aEffect))
+        if (auto* instanceVST = reinterpret_cast<VSTPluginInstance*> (vstAEffect->hostSpace2))
             return dynamic_cast<AudioPluginInstance*> (instanceVST);
 
     return nullptr;
